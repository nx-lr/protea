name: Protea
scopeName: source.spwn
fileTypes: [protea, spwn]
patterns: [include: "#core"]

informationForContributors: |
  This is the grammar for the Protea programming language.

  The grammar is nearing completion but needs to be thoroughly refactored and
  reorganized. There also are some bugfixes which are on the verge of being
  performed.

  Should you feel any fix or improvements have to be made, or even some general
  constructive feedback, make a pull request or an issue on this repo, and I
  will be very happy to receive it/them.

changelog: |
  New changes:

  - Syntax now closely resembles JavaScript's. This includes keywords, comments,
    literals, strings etc. Many parts of this document have been changed.
  - Large regular expressions scattered through this document also have been
    fixed up to be more readable to any editors out there. It once was presented
    in a rather unpretty format.
    - [x] Markdown syntax
    - [x] function parameters
    - [x] function calls
    - [x] identifiers and variables
    - [x] operators
    - [x] object literals
    - [x] object labels
    - [x] pipeline functions
    - [x] modifier keywords
    - [x] function assignments
    - [x] anonymous functions
    - [x] embedded content
    - [x] rounded and square brackets
    - [x] LINQ, inline SQL and constraint syntax (more to come later)
  - Numbers and escape sequences have been reworked, and will no longer accept
    integers bigger than decimal 1114111 which now are highlighted as an error.
  - Bases 4, 6, and 12 have been scrapped, though a multi-base generic numeric
    literal is still in the works.
  - Interpolation and formatting syntax have been reworked and fixed, and can now
    span multiple lines and beyond 20 nested layers thanks to applyEndPatternLast.
    Because of this, spacing around most of the patterns here have also been removed;
    a separate space scope is added to join everything together.
  - Function call syntax is heavily standardized and would need a later fix in
    the long run. This is if a more terser variant of SagaScript is in the need.
    and if so would be inspired by Haskell.
  - Fixed some bugs with regular expressions:
    - Added and expanded quantifiers and range highlighting
    - Add support for fuzzy matching (edits, insertions, deletions, etc.)
    - Improved highlighting for regexes with flags
  - Added prefixes to strings.
  - Switched around regular expressions: / triggers a regex when it begins an
    expression. ` is now used to open unquoted strings.
  - Two (or more) regular expressions in a row on the same line without a comma
    triggers a replacement string instead of a normal regular expression literal.
  - Changed up syntax highlighting of switch and match statements to be more
    consistent with JavaScript.
  - Function calls now trigger beside ( and {.
  - Added Perl/Ruby's unless and until keywords.
  - Fixed module syntax to be more consistent with JavaScript.
  - Dashes are no longer allowed in identifiers.
  - Fixed JSX highlighting and attributes, inspired by Svelte, Angular (TS), HAML
    - @directive
    - #id and .class
    - :event and |pipe (both from Svelte)
    - %directive
    - &reference and *spread
    - ?boolean and @property (from Lit)
  - Added script blocks for injection of raw JavaScript.
  - Fixed keys in literal objects
  - Fixed modifier keywords beside function literals
  - Fixed default values in function arguments, thus no longer requiring trailing
    commas. Only exception now is the (infix/suffix) operator '|' and an unquoted
    string ending in '|'.
  - Slightly changed attribute selectors to allow for regexp matches.

  Fixes:

  - Plan and add Trinity's standard library, then integrate it into the grammar.
    This would all be done in a separate PR and once the grammar is completely
    finished.
    - A handful of built-in properties and constants are part of this grammar
      and are used to highlight CSS properties, constants and HTML tags. Other
      than that, nothing else is present...
      at least not in the moment
    - This features would include:
      - Type, interface, module/namespace and class names
      - Functions and methods
      - Constants and properties
      - Special variables
      - Various UI elements and color names
      - Character names (LaTeX/HTML/AGLFN)
  - Add new parameter binding/destructuring syntax for:
    - [ ] Strings
    - [ ] Regular expressions
    - [ ] Arrays
    - [ ] Sets
    - [ ] Maps and objects
    - [ ] Tuples
    - [ ] Function arguments
    - [ ] Variables
  - Match unquoted globs in routes
  - Fix syntax for JavaScript ES5 module import and export statements
  - Revamp Markdown syntax with these extensions:
    - [ ] Citations
    - [ ] Strike-through
    - [ ] Deleted and inserted text
    - [ ] Superscript
    - [ ] Subscript
    - [ ] Spans
    - [ ] Selectors and anchors
    - [ ] Code blocks
    - [ ] Definition blocks
    - [ ] Tables
    - [ ] Headings and subheadings

define:
  entity-name: &entity-name |
    (?x) \s*\b

    (?!
      (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        in|of|as|is|new
        |to|till|thru|by|delete
        |unset|ref|and|or|xor|not
        |var|val|let|const|function
        |procedure|method|type|class
        |interface|enum|module|struct
        |protocol|iterator|macro|query
        |object|contract|trait|style|script
        |element|field|model|namespace
        |go|defer|do|with|from|where
        |if|unless|else|then|declare
        |for|foreach|repeat|while|until
        |try|throw|catch|finally|switch
        |match|case|fallthru|default|goto
        |break|continue|redo|retry
        |return|yield|await|scope
        |import|export|route
        |debug|assert|check
      )
      \b
    )

    # identifier
    ([\p{Pc}\p{L}]\w*)
    \b

  keywords: |
    (?x) \s* \b

    (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        in|of|as|is|new
        |to|till|thru|by|delete
        |unset|ref|and|or|xor|not
        |var|val|let|const|function
        |procedure|method|type|class
        |interface|enum|module|struct
        |protocol|iterator|macro|query
        |object|contract|trait|style|script
        |element|field|model|namespace
        |go|defer|do|with|from|where
        |if|unless|else|then|declare
        |for|foreach|repeat|while|until
        |try|throw|catch|finally|switch
        |match|case|fallthru|default|goto
        |break|continue|redo|retry
        |return|yield|await|scope
        |import|export|route
        |debug|assert|check
      )
    \b

    \b

  html-tag-names: &html-tag-names
    - match: '\.|:|::'
      name: punctuation.separator.namespace.protea
    - match: \b([\p{Pc}\p{L}]\w*)\b(?=[:.])
      name: entity.name.tag.namespace.protea
    - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)\b
      name: support.class.component.protea
    - include: "#clauses"
    - include: "#declarations"
    - include: "#keywords"
    - include: "#html-tag-names"

repository:
  core:
    patterns:
      - include: "#ignore-long-lines"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#comments"
      - include: "#argument-list"
      - include: "#function-clause"
      - include: "#symbols"
      - include: "#decorators"
      - include: "#type-signature"
      - include: "#illegal-identifier"
      - include: "#jsx"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#literals"
      - include: "#operators"
      - include: "#function-calls"
      - include: "#variables"
      - include: "#illegal"
      - include: "#space"

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^.{1024,}$

  space:
    match: \s+
    name: meta.var.expr.protea

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.protea
      - match: '[\w]+?'
        name: invalid.illegal.variable.protea
      - match: '[({\[)}\]]+?'
        name: invalid.illegal.missing-bracket.protea
      - match: '[\p{S}\p{P}&&[^,;''"`({\[)}\]\p{Pc}]]+'
        name: invalid.illegal.operator.protea
      - match: \S+?
        name: invalid.illegal.uncaught.protea

  illegal-identifier:
    applyEndPatternLast: true
    name: meta.type.protea
    begin: (?<=\w+\b)\s*(?=\b\w+)
    end: (?=)|$
    patterns:
      - match: \s*\w+\s*
        name: invalid.illegal.identifier.protea

  # Types

  types:
    patterns:
      - include: "#comments"
      - include: "#embedded-expression"
      - include: "#argument-list"
      - include: "#angle-brackets"
      - include: "#modifiers"
      - include: "#type-keywords"
      - include: "#type-names"
      - include: "#literals"
      - include: "#type-variables"
      - include: "#type-operators"
      - include: "#type-brackets"
      - include: "#space"

  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x) \s* \b

      (?!
        (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?: # keywords
          in|of|as|is|new
          |to|till|thru|by|delete
          |unset|ref|and|or|xor|not
          |var|val|let|const|function
          |procedure|method|type|class
          |interface|enum|module|struct
          |protocol|iterator|macro|query
          |object|contract|trait|style|script
          |element|field|model|namespace
          |go|defer|do|with|from|where
          |if|unless|else|then|declare
          |for|foreach|repeat|while|until
          |try|throw|catch|finally|switch
          |match|case|fallthru|default|goto
          |break|continue|redo|retry
          |return|yield|await|scope
          |import|export|route
          |debug|assert|check
          |extends|implements
        )
        \b
      )

      (?:
        (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?))
        (?: # Properties
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        |
        (?: # Objects
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        (?=(?:[!?]?\.=?|[?!:]:=?|<)(?:[,;'"`(){}\[\]\w\s]|$))
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
      )\b

      \s*
    captures:
      1: {name: entity.name.trait.protea}
      2: {name: entity.name.interface.protea}
      3: {name: entity.name.interface.protea}
      4: {name: entity.name.trait.protea}
      5: {name: entity.name.module.protea}
      6: {name: entity.name.namespace.protea}
      7: {name: entity.name.namespace.protea}
      8: {name: entity.name.module.protea}
      9: {name: entity.name.type.protea}
      10: {name: entity.name.class.protea}
      11: {name: entity.name.class.protea}
      12: {name: entity.name.type.protea}

  type-signature:
    applyEndPatternLast: true
    name: meta.type.protea
    begin: (?<=(?:[)}\]\w\s'"`]|\\.)\|?|^\|?)(:)(?=$|[\w\s'"`({\[])
    end: (?=)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.protea}
    patterns:
      - include: "#types"

  type-brackets:
    patterns:
      - include: "#type-curly-brackets"
      - include: "#type-square-brackets"
      - include: "#type-round-brackets"

  type-curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.protea
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.protea

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.binding-pattern.object.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#as-keyword"
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.dictionary.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.dictionary.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#types"
          - include: $self

  type-round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.protea
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.protea
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.protea}
        patterns:
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: {name: punctuation.definition.tuple.protea}
        patterns:
          - include: "#types"
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: {name: punctuation.definition.expression.protea}
        patterns:
          - include: "#types"
          - include: $self

  type-square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.sequence.protea
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.attribute-selector.protea}
        patterns:
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.binding-pattern.array.protea}
        patterns:
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.sequence.protea}
        patterns:
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.array.protea}
        patterns:
          - include: "#punctuation"
          - include: "#types"
          - include: $self

  type-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(extends|implements)\b\s*
        name: storage.type.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(infer|as|is)\b\s*
        name: keyword.operator.expression.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((instance|value|pair|type|name|size|key)of)\b\s*
        name: keyword.operator.expression.$1.protea

  type-operators:
    old:
      - comment: Function types
        match: (?:^|\s+)(?:(\|)|(>))(?=['"`({\[\w])|(?<=['"`)}\]\w])(?:(\|)|(<))(?:$|\s+)
        captures:
          1: {name: keyword.operator.type.function.protea}
          2: {name: keyword.operator.type.channel.protea}
          3: {name: keyword.operator.type.function.protea}
          4: {name: keyword.operator.type.channel.protea}

    patterns:
      - &qualified-name-separators
        comment: Primary binary operators
        match: (?<=[)}\]\w])(?:(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=[({\[\w])
        captures:
          1: {name: keyword.operator.optional.protea}
          2: {name: keyword.operator.assert.protea}
          3: {name: keyword.operator.accessor.protea}
      - match: \s*(--?>|~~?>|==?>)
        name: keyword.operator.type.function.protea
      - match: \s*(<--?|<~~?|<==?)
        name: keyword.operator.type.channel.protea
      - comment: type unions
        match: (?<=^|[\s({\[])(\|)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\|)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.union.protea}
          2: {name: keyword.operator.union.protea}
      - comment: type operators
        match: |
          (?x)
          (?<=^|[,;'"`({\[)}\]\w\s]|\\.)
            (?:
              (\+)|(\-)|(\*)|(\/)|(\%)|(\!)
              |(\?)|(\&)|(\^)|(\~)|(\$)|(:[<>]|[<>]:)
            )
          (?=$|[,;'"`({\[)}\]\w\s])
        captures: &type-operators
          1: {name: keyword.operator.sum.protea}
          2: {name: keyword.operator.difference.protea}
          3: {name: keyword.operator.product.protea}
          4: {name: keyword.operator.quotient.protea}
          5: {name: keyword.operator.remainder.protea}
          6: {name: keyword.operator.only.protea}
          7: {name: keyword.operator.maybe.protea}
          8: {name: keyword.operator.intersection.protea}
          9: {name: keyword.operator.symmetric.protea}
          10: {name: keyword.operator.negation.protea}
          11: {name: keyword.operator.macro.dollar.protea}
          12: {name: keyword.operator.class.protea}

  # Literals and Constants

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings"
      - include: "#numbers"
      - include: "#constants"
      - include: "#strings-unquoted"

  constants:
    patterns:
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (true|false) # boolean
            |(null|nan|undefined|infinity) # null, NaN
          )
          \b
        captures:
          1: {name: constant.language.boolean.$1.protea}
          2: {name: constant.language.$2.protea}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (it|this|super|self) # special arguments
            |(params) # arguments
            |(constructor) # constructor
            |(prototype) # prototype
          )
          \b
        captures:
          1: {name: variable.language.$1.protea}
          2: {name: variable.language.arguments.protea}
          3: {name: variable.language.constructor.protea}
          4: {name: variable.language.prototype.protea}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (
            console|document|window|global|process|require|module|exports
            |navigator|location|history|localStorage|sessionStorage
          )
          \b
        captures:
          1: {name: support.type.object.$1.protea}

  # Numbers

  numbers:
    applyEndPatternLast: true
    begin: (?<!\.)(?=\d)
    end: \b
    name: meta.number.protea
    patterns:
      - comment: hexadecimal integers
        name: constant.numeric.hexadecimal.protea
        match: |
          (?ix) \b
            (0x) # prefix
            \h [\h_]* # integer part
            (\.)? # decimal point
            [\h_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.protea}
          2: {name: keyword.other.unit.protea}
          3: {name: keyword.operator.expression.exponent.protea}
          4: {name: keyword.operator.exponent.sign.protea}
          5: {name: constant.numeric.decimal.exponent.mantissa.protea}
          6: {name: keyword.other.unit.protea}
      - comment: octal integers
        name: constant.numeric.octal.protea
        match: |
          (?ix) \b
            (0o) # prefix
            [0-7] [0-7_]* # integer part
            (\.)? # decimal point
            [0-7_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.protea}
          2: {name: keyword.other.unit.protea}
          3: {name: keyword.operator.expression.exponent.protea}
          4: {name: keyword.operator.exponent.sign.protea}
          5: {name: constant.numeric.decimal.exponent.mantissa.protea}
          6: {name: keyword.other.unit.protea}
      - comment: binary 0b
        name: constant.numeric.binary.protea
        match: |
          (?ix) \b
            (0b) # prefix
            [01] [01_]* # integer part
            (\.)? # decimal point
            [01_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.protea}
          2: {name: keyword.other.unit.protea}
          3: {name: keyword.operator.expression.exponent.protea}
          4: {name: keyword.operator.exponent.sign.protea}
          5: {name: constant.numeric.decimal.exponent.mantissa.protea}
          6: {name: keyword.other.unit.protea}
      - comment: decimal (no prefix)
        name: constant.numeric.decimal.protea
        match: |
          (?ix) \b
            () # prefix
            \d [\d_]* # integer part
            (\.)? # decimal point
            [\d_]* # fractional part
            (?: # exponent part
              (e) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.protea}
          2: {name: keyword.other.unit.protea}
          3: {name: keyword.operator.expression.exponent.protea}
          4: {name: keyword.operator.exponent.sign.protea}
          5: {name: constant.numeric.decimal.exponent.mantissa.protea}
          6: {name: keyword.other.unit.protea}

  # Symbols

  decorators:
    applyEndPatternLast: true
    begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(\@)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    name: entity.name.decorator.protea
    captures:
      1: {name: punctuation.definition.decorator.protea}
      2: {name: entity.name.decorator.protea}
    patterns:
      - include: "#function-calls"
      - include: "#sigil-function-calls"
      - match: ::|\.
        name: punctuation.separator.namespace.protea
      - include: "#brackets"
      - include: "#strings"
      - include: "#variables"

  symbols:
    patterns:
      - comment: quoted symbol
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(?=[`'"])
        end: (?=)|$
        name: constant.language.symbol-type.protea
        captures:
          1: {name: punctuation.definition.symbol.protea}
        patterns:
          - include: "#strings-single-quoted"
          - include: "#strings-double-quoted"
          - include: "#strings-unquoted"
      - match: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(\b[\p{Pc}\p{L}]\w*\b)
        name: constant.other.symbol.protea
        captures:
          1: {name: punctuation.definition.symbol.protea}
          2: {name: constant.other.symbol.protea}
        patterns:
          - include: "#string-escapes"

  strings-unquoted:
    comment: Unquoted string
    applyEndPatternLast: true
    begin: (`)
    end: (?=\W)|$
    name: string.template.protea
    captures:
      1: {name: punctuation.definition.string.protea}
    patterns:
      - match: \b\p{Pd}+\b
      - include: "#string-escapes"

  strings:
    patterns:
      - include: "#strings-prefixed"
      - include: "#strings-double-quoted"
      - include: "#strings-single-quoted"

  strings-single-quoted:
    patterns:
      - comment: single-quoted plain string
        begin: (?<!'+)((?i:\p{L}+))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
      - comment: single-quoted plain string
        begin: (?<!'+)((?i:))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"

  strings-double-quoted:
    patterns:
      - comment: double-quoted plain string
        begin: (?<!"+)((?i:\p{L}+))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
      - comment: double-quoted plain string
        begin: (?<!"+)((?i:))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"

  string-content:
    patterns:
      - include: "#string-escapes"
      - include: "#embedded"

  string-escapes:
    patterns:
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.protea}
      - include: "#named-escapes"
      - include: "#numeric-escapes"
      - match: \\([cm][a-z])
        name: constant.character.control.protea
      - match: \\[abefprnstv]
        name: constant.character.escape.protea
      - match: \\\p{S}
        name: constant.character.escape.symbol.protea
      - match: \\\p{P}
        name: constant.character.escape.punctuation.protea
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.protea
      - match: \\\s
        name: constant.character.escape.space.protea
      - match: \\\p{L}
        name: constant.character.escape.letter.protea
      - match: \\\p{N}
        name: constant.character.escape.number.protea
      - match: \\.
        name: constant.character.escape.other.protea

  named-characters:
    name: string.unquoted.plain.in.protea
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.protea
        begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1: {patterns: [include: "#function-namespace"]}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.protea}
            patterns:
              - include: "#named-characters"
      - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.protea
        captures:
          1: {patterns: [include: "#character-namespace"]}
      - include: "#string-content"
      - include: "#punctuation"
      - include: "#illegal"

  function-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: support entity.name.tag.namespace.protea
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: support entity.name.function.member.protea

  character-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: constant.other.character-class.protea
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: constant.character.escape.unicode.protea

  named-escapes:
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.protea
        begin: \\N([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1: {patterns: [include: "#function-namespace"]}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.protea}
            patterns:
              - include: "#named-characters"
      - match: \\N([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.protea
        captures:
          1: {patterns: [include: "#character-namespace"]}
      - begin: \\N{\s*
        end: \s*}
        name: constant.other.character-class.unicode.protea
        patterns:
          - applyEndPatternLast: true
            name: constant.other.function.protea
            begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
            beginCaptures:
              1: {patterns: [include: "#function-namespace"]}
            end: (?=)|$
            patterns:
              - begin: (\{)
                end: (\})
                captures:
                  1: {name: constant.other.function.protea}
                patterns:
                  - include: "#named-characters"
          - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
            name: constant.character.escape.protea
            captures:
              1: {patterns: [include: "#character-namespace"]}
          - include: "#string-content"
          - include: "#punctuation"
          - include: "#illegal"

  numeric-escapes:
    comments: |
      Hexadecimal escapes \u encode UTF-16 while \x encodes UTF-8 code points
      in addition to Unicode characters.
    patterns:
      - comment: Binary escape sequences (0 to 417777)
        match: |
          (?x)
          \\b # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111
              10000[01]{16}
            | [01]{1,20}
          )
            (?![01])
        name: constant.character.escape.binary.protea
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\b # prefix
            [01]+
            (?![01])
        name: invalid.illegal.escape.binary.protea
      - begin: \\b{
        end: \s*}
        name: constant.character.escape.binary.protea
        patterns:
          - include: "#punctuation"
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111
                  10000[01]{16}
                | [01]{1,20}
              )
                (?![01])
            name: constant.character.escape.binary.protea
          - include: "#illegal"

      - comment: Octal escape sequences (0 to 417777)
        match: |
          (?x)
          \\o # prefix
            0* # leading zeroes
          (?: # numbers leading to 417777
              4[01][0-7]{4}
            | [1-3][0-7]{5}
            | [1-7][0-7]{1,4}
            | [0-7]
          )
            (?![0-7])
        name: constant.character.escape.octal.protea
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\o # prefix
            [0-7]+
            (?![0-7])
        name: invalid.illegal.escape.octal.protea
      - begin: \\o{
        end: \s*}
        name: constant.character.escape.octal.protea
        patterns:
          - include: "#punctuation"
          - match: |
              (?x)
                \b
              0* # leading zeroes
              ( # numbers up to 417777
                  4[01][0-7]{4}
                | [1-3][0-7]{5}
                | [1-7][0-7]{1,4}
                | [0-7]
              )
                (?![0-7])
            name: constant.character.escape.octal.protea
          - include: "#illegal"

      - comment: Decimal escapes (0 to 1114111)
        match: |
          (?x)
          \\d? # prefix
            0* # leading zeroes
          (?: # numbers up to 1114111
              111411[01]
            | 111410\d
            | 11140\d{2}
            | 111[0-3]\d{3}
            | 110\d{4}
            | 10\d{5}
            | [1-9]\d{1,5}
            | \d
          )
            (?!\d)
        name: constant.character.escape.decimal.protea
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\d? # prefix
            \d+
            (?!\d)
        name: invalid.illegal.escape.decimal.protea
      - begin: \\d{
        end: \s*}
        name: constant.character.escape.decimal.protea
        patterns:
          - include: "#punctuation"
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers up to 1114111
                  111411[01]
                | 111410\d
                | 11140\d{2}
                | 111[0-3]\d{3}
                | 110\d{4}
                | 10\d{5}
                | [1-9]\d{1,5}
                | \d
              )
                (?!\d)
            name: constant.character.escape.decimal.protea
          - include: "#illegal"

      - comment: Trailing byte pair U+80-U+BF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            [89ab]\h
          )
            (?!\h)
        name: constant.character.escape.trailing.protea
      - comment: Leading byte pair U+C0-U+FF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # C0 to FF
                [c-f]\h
            )
          )
            (?!\h)
        name: constant.character.escape.leading.protea
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.hexadecimal.protea
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
          \\x # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.hexadecimal.protea
      - begin: \\x{
        end: \s*}
        name: constant.character.escape.hexadecimal.protea
        patterns:
          - include: "#punctuation"
          - comment: Trailing byte pair U+80-U+BF
            match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                [89ab]\h # 80 to BF
              )
                (?!\h)
            name: constant.character.escape.trailing.protea
          - comment: Leading byte pair U+C0-U+FF
            match: |
              (?x)
                \b # prefix
              (?i:
                0* # leading zeroes
                (?: # C0 to FF
                    [c-f]\h
                )
              )
                (?!\h)
            name: constant.character.escape.leading.protea
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.hexadecimal.protea
          - include: "#illegal"

      - comment: Low surrogate pairs U+DC00-DFFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[c-f] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.low.protea
      - comment: High surrogate pairs U+D800-DBFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[89ab] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.high.protea
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.unicode.protea
      - comment: Unicode escape sequences
        match: |
          (?x)
          \\u # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.unicode.protea
      - comment: Unicode escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
            (?!\h)
          )
        name: constant.character.escape.unicode.protea
      - comment: Unicode escapes
        begin: \\u{
        end: \s*}
        name: constant.character.escape.unicode.protea
        patterns:
          - include: "#punctuation"
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [c-f] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.low.protea
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [89ab] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.high.protea
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.unicode.protea
          - include: "#illegal"

  # Embedded expressions

  embedded:
    patterns:
      - include: "#embedded-expression"
      - include: "#embedded-format"
      - include: "#embedded-placeholder"

  embedded-verbatim:
    patterns:
      - match: \#\#|\$\$|\%\%
        name: constant.character.escape.protea
      - include: "#embedded-expression"
      - include: "#embedded-format"
      - include: "#embedded-placeholder"

  embedded-expression:
    patterns:
      - comment: Interpolated expression
        begin: (\${)\s*
        end: \s*(})
        name: meta.embedded.expression.protea
        captures:
          1: {name: punctuation.definition.variable.protea}
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.protea
        begin: |
          (?x)
          (\$) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style|script
              |element|field|model|namespace
              |go|defer|do|with|from|where
              |if|unless|else|then|declare
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.variable.protea}
        patterns:
          - include: "#constants"
          - include: "#brackets"
          - include: "#embedded-function-calls"
          - include: "#variables"
          - include: "#numbers"
          - *qualified-name-separators

  interpolated-code:
    patterns:
      - comment: Interpolated expression
        begin: (\#{)\s*
        end: \s*(})
        name: meta.embedded.expression.protea
        captures:
          1: {name: punctuation.definition.variable.protea}
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.protea
        begin: |
          (?x)
          (\#) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style|script
              |element|field|model|namespace
              |go|defer|do|with|from|where
              |if|unless|else|then|declare
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.variable.protea}
        patterns:
          - include: "#constants"
          - include: "#brackets"
          - include: "#embedded-function-calls"
          - include: "#variables"
          - include: "#numbers"
          - *qualified-name-separators

  embedded-placeholder:
    patterns:
      - name: meta.embedded.placeholder.protea
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?)? # sigil
              [!?]? # required or optional
            )?
            [+-]? \d+ # start of range
            (?:
              (?:[>.]\.[.<] | \.\. | [=.]\.[.=]|\.\.=?|=\.=) # range operator
              [+-]? \d+ # end of range
              (?:
                \.{1,3}
                [+-]? \d+ # increment
              )?
            )?
          )
        captures:
          1: {name: punctuation.definition.anchor.protea}
          2:
            name: constant.numeric.decimal.protea
            patterns:
              - match: "[+-]"
                name: keyword.operator.arithmetic.protea
              - match: (?:[>.]\.[.<] | \.\. | [=.]\.[.=]|\.\.=?|=\.=)
                name: keyword.operator.range.protea
      - name: meta.embedded.placeholder.protea
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?) # sigil
              [!?]? # required or optional
            )
            \b
              [\p{Pc}\p{L}]\w*
            \b
            |
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
                |var|val|let|const|function
                |procedure|method|type|class
                |interface|enum|module|struct
                |protocol|iterator|macro|query
                |object|contract|trait|style|script
                |element|field|model|namespace
                |go|defer|do|with|from|where
                |if|unless|else|then|declare
                |for|foreach|repeat|while|until
                |try|throw|catch|finally|switch
                |match|case|fallthru|default|goto
                |break|continue|redo|retry
                |return|yield|await|scope
                |import|export|route
                |debug|assert|check
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
        captures:
          1: {name: punctuation.definition.anchor.protea}
          2: {patterns: [include: "#placeholder-variables"]}
      - name: meta.embedded.placeholder.protea
        begin: (\#{)\s*
        end: \s*(})
        captures:
          1: {name: punctuation.definition.anchor.protea}
        patterns:
          - include: "#parameter-variables"
          - include: $self

  # Format and flag specifiers

  switch-clause:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s])(//)(?=[\p{Pc}\p{L}])
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.protea}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.other.flag.protea}
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s])(/)(?=[\p{Pc}\p{L}])
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.protea}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.modifier.protea}

  embedded-format:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: true
    name: meta.embedded.formatting.protea
    begin: (?<!%)(%)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    captures:
      1: {name: punctuation.definition.directive.protea}
    patterns:
      - include: "#format-syntax"

  format-syntax:
    comment: Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: with optional value
        applyEndPatternLast: true
        begin: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b(:)
        end: (?=)|$
        name: storage.type.format.protea
        captures:
          1: {name: punctuation.separator.mapping.protea}
          2: {name: storage.type.format.protea}
          3: {name: punctuation.separator.key-value.protea}
        patterns: &format-values
          - include: "#constants"
          - include: "#embedded-function-calls"
          - include: "#variables"
          - include: "#brackets"
          - include: "#regexps"
          - include: "#numbers"
          - include: "#symbols"
          - *qualified-name-separators
      - comment: type specifier
        match: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.protea
        captures:
          1: {name: punctuation.separator.mapping.protea}
          2: {name: storage.type.format.protea}

  # Regular expressions

  attribute-patterns:
    patterns:
      - applyEndPatternLast: true
        comment: Pattern section
        begin: (/>)\s*
        end: \s*(</)(\p{L}*)
        name: string.regexp.pattern.protea
        captures:
          1: {name: punctuation.definition.regexp.protea}
          2: {name: keyword.other.flag.protea}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
          - comment: Replacement section
            begin: (</>)\s*
            end: \s*(?=</)
            name: string.regexp.replace.protea
            captures:
              1: {name: punctuation.definition.regexp.protea}
            patterns:
              - include: "#back-references"
              - include: "#string-content"
      - comment: Pattern section
        begin: (/)\s*
        end: \s*(/)(\p{L}*)
        name: string.regexp.pattern.protea
        captures:
          1: {name: punctuation.definition.regexp.protea}
          2: {name: keyword.other.flag.protea}
        patterns:
          - include: "#regexp-patterns"

  regexps:
    applyEndPatternLast: true
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style|script
              |element|field|model|namespace
              |go|defer|do|with|from|where
              |if|unless|else|then|declare
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (?= />?)
    end: (?=)|$
    name: meta.regexp.protea
    patterns:
      - applyEndPatternLast: true
        comment: Pattern section
        begin: (/>)\s*
        end: \s*(</)(\p{L}*)
        name: string.regexp.pattern.protea
        captures:
          1: {name: punctuation.definition.regexp.protea}
          2: {name: keyword.other.flag.protea}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
          - comment: Replacement section
            begin: (</>)\s*
            end: \s*(?=</)
            name: string.regexp.replace.protea
            captures:
              1: {name: punctuation.definition.regexp.protea}
            patterns:
              - include: "#back-references"
              - include: "#string-content"
      - comment: Pattern section
        begin: (/)\s*(?=(?:[^\\/]|\\.)+/\p{L}*)
        end: \s*(/)(\p{L}*)
        name: string.regexp.pattern.protea
        captures:
          1: {name: punctuation.definition.regexp.protea}
          2: {name: keyword.other.flag.protea}
        patterns:
          - include: "#regexp-patterns"

  fuzzy-expression:
    patterns:
      - include: "#punctuation"
      - include: "#comments"
      - include: "#function-calls"
      - include: "#literals"
      - include: "#embedded"
      - include: "#operators"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#fuzzy-brackets"
      - match: \b[\p{Pc}\p{L}]\w*\b
        name: keyword.other.unit.protea
      - include: "#space"

  fuzzy-brackets:
    patterns:
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - match: ","
            name: punctuation.separator.mapping.protea
          - include: "#labels"
          - include: "#fuzzy-expression"
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.protea}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.protea
          - include: "#fuzzy-expression"
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.protea}
        patterns:
          - match: ","
            name: punctuation.separator.arguments.protea
          - include: "#fuzzy-expression"
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*)
        name: keyword.other.back-reference.protea
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: &regex-back-references
          - include: "#variables"
          - include: "#numbers"
          - include: "#operators"
          - include: "#string-content"
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: *regex-back-references

  regexp-patterns:
    patterns:
      - include: "#comments"
      - include: "#embedded"
      - include: "#strings"
      - match: \|
        name: keyword.operator.or.protea
      - match: \&
        name: keyword.operator.compose.protea
      - match: \.
        name: constant.character.all.protea
      - match: \\[bB](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.anchor.protea
      - match: \$|\\[yYzZ](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.end.protea}
      - match: \^|\\[AmM](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.begin.protea
      - match: \\K
        name: keyword.control.keepout.protea
      - match: \\G
        name: keyword.control.search.protea
      - match: \\R
        name: constant.character.control.protea
      - match: \\[XO]
        name: constant.character.unicode.protea
      - match: \\\d+
        name: keyword.other.back-reference.protea
      - match: \{\s*(?:\d*\s*,){,2}\s*\d*\s*}\s*(?:(\?)|(\+)|(\*))?
        captures:
          0: {name: keyword.operator.quantifier.protea}
          1: {name: keyword.operator.modifier.lazy.protea}
          2: {name: keyword.operator.modifier.eager.protea}
          3: {name: keyword.operator.modifier.greedy.protea}
      - match: (?:(\?)|(\+)|(\*))\s*(?:(\?)|(\+)|(\*))?
        captures:
          1: {name: keyword.operator.quantifier.lazy.protea}
          2: {name: keyword.operator.quantifier.eager.protea}
          3: {name: keyword.operator.quantifier.greedy.protea}
          4: {name: keyword.operator.modifier.lazy.protea}
          5: {name: keyword.operator.modifier.eager.protea}
          6: {name: keyword.operator.modifier.greedy.protea}
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.protea
        captures:
          1: {name: keyword.other.subroutine.protea}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.subroutine.protea
        captures:
          1: {name: keyword.other.subroutine.protea}
        patterns: *regex-back-references
      - begin: ({)
        end: \s*(})
        name: meta.fuzzy.protea
        captures:
          1: {name: punctuation.definition.fuzzy.protea}
        patterns:
          - applyEndPatternLast: true
            begin: (?<=^|\\.|[,;'"`({\[)}\]\w\s])(:)
            beginCaptures:
              1: {name: punctuation.separator.key-value.protea}
            end: (?=[,;}]|)|$
            patterns: &regexp-patterns
              - include: "#regexp-patterns"
          - include: "#fuzzy-expression"
      - match: \\[abefrntv]
        name: constant.character.escape.protea
      - match: \\[wsdhulqmji]
        name: constant.other.character-class.protea
      - match: \\[WSDHULQMJI]
        name: constant.other.character-class.negated.protea
      - include: "#regexp-groups"
      - include: "#regexp-character-set"
      - include: "#regexp-character-class"
      - include: "#space"

  regexp-groups:
    patterns:
      - comment: Backtracking control verb
        begin: (\(\*([\p{Pc}\p{L}]\w*)?(:)?)
        end: \s*(\))
        name: meta.group.backtrack.protea
        captures:
          1: {name: punctuation.section.expression.protea}
          2: {name: keyword.control.protea}
          3: {name: punctuation.separator.colon.protea}
        patterns: *regexp-patterns
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.protea
        end: \s*(\))
        name: comment.block.regexp.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - match: \\.
            name: comment.block.regexp.protea
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.protea
        captures:
          1: {name: punctuation.definition.group.look-ahead.protea}
        patterns: *regexp-patterns
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.protea
        captures:
          1: {name: punctuation.definition.group.look-behind.protea}
        patterns: *regexp-patterns
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.protea
        captures:
          1: {name: punctuation.definition.group.negative-look-ahead.protea}
        patterns: *regexp-patterns
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.protea
        captures:
          1: {name: punctuation.definition.group.negative-look-behind.protea}
        patterns: *regexp-patterns
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: (?x)(\(\?)(?=%)
        captures:
          1: {name: punctuation.definition.directive.protea}
        end: \s*(\))
        name: meta.group.directive.protea
        patterns:
          - include: "#format-syntax"
          - include: "#regexp-patterns"
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.protea
        captures:
          1: {name: punctuation.definition.group.longest.protea}
        patterns: *regexp-patterns
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.protea
        captures:
          0: {name: punctuation.definition.group.flag.protea}
          1: {name: punctuation.definition.group.flag.protea}
          2: {name: constant.numeric.index.protea}
          3: {name: keyword.control.recursion.protea}
          4: {name: keyword.other.flag.protea}
          5: {name: punctuation.separator.colon.protea}
        patterns: *regexp-patterns
      - comment: Call-outs
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.protea
        captures:
          1: {name: punctuation.definition.group.call-out.protea}
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.protea
            captures:
              1: {name: punctuation.definition.group.call-out.protea}
              2: {name: keyword.operator.range.protea}
              3: {name: punctuation.definition.tag.protea}
              4: {patterns: [include: "#function-names"]}
              5: {name: punctuation.definition.tag.protea}
            patterns:
              - include: $self
          - include: "#regexp-patterns"
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.protea
        captures:
          1: {name: punctuation.definition.group.atomic.protea}
        patterns: *regexp-patterns
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.protea
        captures:
          1: {name: punctuation.definition.group.non-capturing.protea}
        patterns: *regexp-patterns
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.protea
        captures:
          1: {name: punctuation.definition.group.branch.protea}
        patterns: *regexp-patterns
      - comment: Atomic groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.protea
        captures:
          1: {name: punctuation.definition.group.absent.protea}
        patterns: *regexp-patterns
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}]\w*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.protea
        captures:
          0: {name: punctuation.definition.group.back-reference.protea}
          1: {name: punctuation.definition.group.back-reference.protea}
          2: {name: constant.numeric.index.protea}
          3: {patterns: [include: "#variables"]}
          4: {name: punctuation.separator.colon.protea}
        patterns: *regexp-patterns
      - comment: Named groups (angle-brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.protea
        captures:
          0: {name: punctuation.definition.group.named.protea}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.protea
            captures:
              1: {name: punctuation.definition.group.named.protea}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.protea
        captures:
          0: {name: punctuation.definition.group.named.protea}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.protea
            captures:
              1: {name: punctuation.definition.group.named.protea}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.protea
        captures:
          1: {name: punctuation.definition.group.protea}
        patterns: *regexp-patterns

  regexp-character-class:
    patterns:
      - include: "#embedded"
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.protea}
      - include: "#named-escapes"
      - include: "#numeric-escapes"
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.protea
        patterns:
          - include: "#attribute-selectors"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.protea
      - match: (?i)\\p[a-z]{1,2}
        name: constant.other.character-class.unicode.protea
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.protea
      - match: (?i)\\n{(?:[^\\{}]|\\.)+}
        name: constant.character.escape.unicode.name.protea
      - match: \\[abefprntv]
        name: constant.character.escape.protea
      - match: \\[a-z]
        name: constant.other.character-class.protea
      - match: \\[A-Z]
        name: constant.other.character-class.negated.protea
      - match: \\\p{S}
        name: constant.character.escape.symbol.protea
      - match: \\\p{P}
        name: constant.character.escape.punctuation.protea
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.protea
      - match: \\\s
        name: constant.character.escape.space.protea
      - match: \\\p{L}
        name: constant.character.escape.letter.protea
      - match: \\\p{N}
        name: constant.character.escape.number.protea
      - match: \\.
        name: constant.character.escape.other.protea

  regexp-character-operators:
    patterns:
      - match: |
          (?x)
          ( # from
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          )
            \s*
              (-|->|>-|>>) # range
            \s*
          ( # to
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          ) (?:
              \s*
                (:) # range
              \s*
            ( # to
                \d+ # number
              | \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
              | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
              | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
              | \\b(?:[01]+|{[01\s,;]+}) # binary escape
              | \\[cm][a-z] # meta-character
              | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
              | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
              | [^-\\\[\]] # any unescaped character
            )
          )?
        captures:
          1:
            name: constant.other.character-class.range.from.protea
            patterns:
              - include: "#regexp-character-operators"
              - include: "#regexp-character-class"
          2:
            name: keyword.operator.range.protea
          3:
            name: constant.other.character-class.range.to.protea
            patterns:
              - include: "#regexp-character-operators"
              - include: "#regexp-character-class"
          4:
            name: keyword.operator.range.protea
          5:
            name: constant.other.character-class.range.by.protea
            patterns:
              - include: "#numbers"
              - include: "#regexp-character-operators"
              - include: "#regexp-character-class"
      - match: \|\|
        name: keyword.operator.union.protea
      - match: \&&
        name: keyword.operator.intersection.protea
      - match: \^\^
        name: keyword.operator.symmetric.protea
      - match: ~~
        name: keyword.operator.negation.protea
      - match: --
        name: keyword.operator.difference.protea

  regexp-character-set:
    patterns:
      - begin: (\[:)
        end: \s*(:\])
        name: constant.other.character-set.posix.protea
        captures:
          1: {name: punctuation.definition.character-class.posix.protea}
        patterns:
          - include: "#attribute-selectors"
      - begin: (\[\^)
        end: \s*(\])
        name: constant.other.character-set.negated.protea
        captures:
          1: {name: punctuation.definition.character-class.negated.protea}
        patterns:
          - include: "#comments"
          - include: "#regexp-character-operators"
          - include: "#regexp-character-class"
          - include: "#regexp-character-set"
      - begin: (\[)
        end: \s*(\])
        name: constant.other.character-set.protea
        captures:
          1: {name: punctuation.definition.character-class.protea}
        patterns:
          - include: "#comments"
          - include: "#regexp-character-operators"
          - include: "#regexp-character-class"
          - include: "#regexp-character-set"

  attribute-selectors:
    name: meta.attribute-selector.protea
    patterns:
      - match: "[:!=</>.^$%?*+|&~]?="
        name: keyword.operator.pattern.protea
      - match: \&\&|\|\||\^\^|\!
        name: keyword.operator.logical.protea
      - match: ","
        name: punctuation.separator.sequence.protea
      - match: \b(in|is)\b
        name: keyword.operator.expression.$1.protea
      - begin: \b([\p{Pc}\p{L}]\w*)\b([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.key.protea}
          2: {name: keyword.operator.pattern.protea}
        end: (?=\&\&|\|\||\^\^|[\s,:;'"`)}\]]|\\.)
        name: string.unquoted.attribute-name.protea
        patterns:
          - include: "#regexp-patterns"
      - match: (?xi)\b[is]\b\s*(?=[)}\]]|([&|^])\1)
        name: storage.modifier.ignore-when.protea
      - include: "#string-escapes"
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}]\w*)\b
        captures:
          1: {name: entity.other.attribute-name.protea}
          2: {name: keyword.operator.pattern.protea}
      - include: "#comments"
      - include: "#operators"

  # JSX and Markdown

  jsx:
    applyEndPatternLast: true
    comment: Only captured when next to opening brackets, commas, semicolons, keywords, and operators. JSX also supports functional components, so we need to be careful to also match those.
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style|script
              |element|field|model|namespace
              |go|defer|do|with|from|where
              |if|unless|else|then|declare
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (?=<[>\p{Pc}\p{L}])
    end: (?=)|$
    patterns:
      - include: "#tag-component-name"

  tag-component-name:
    patterns:
      - comment: JSX Fragment
        contentName: text.html.fragment.protea
        begin: (<)(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.protea}
        endCaptures:
          1: {name: punctuation.definition.tag.protea}
        patterns:
          - include: "#tag-termination"
      - comment: Tags that end > are trapped in tag-termination
        contentName: text.html.protea
        begin: |
          (?x)
          (<) # start tag begin
          (
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:::|\.?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
            \b
          )
          (?=[,;'"`({\[)}\]/>\s])
        end: |
          (?x) \s*
          (?:
              (?<=</)(\2)(>)
            | (<?/>)
            | ((?<=</)\O*?)>
          )
        beginCaptures:
          1: {name: punctuation.definition.tag.protea}
          2: {patterns: [include: "#tag-names"]}
        endCaptures:
          1: {patterns: [include: "#tag-names"]}
          2: {name: punctuation.definition.tag.protea}
          3: {name: punctuation.definition.tag.protea}
          4: {name: invalid.illegal.termination.protea}
        patterns:
          - include: "#tag-termination"
          - include: "#tag-attributes"

  jsx-comments:
    begin: (<!--)
    end: (-->)
    captures:
      1: {name: punctuation.definition.comment.protea}
    name: comment.block.html.protea
    patterns:
      - include: "#jsx-comments"

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.jsx.children.protea
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.protea}
    patterns:
      - include: "#evaluated-code"
      - include: "#jsx-entities"
      - include: "#tag-component-name"
      - include: "#markdown"
      - include: "#jsx-comments"

  tag-attributes:
    patterns:
      - include: "#literals"
      - include: "#embedded-expression"
      - include: "#brackets"
      - applyEndPatternLast: true
        begin: \s*(=)\s*
        beginCaptures:
          1: {name: punctuation.separator.key-value.protea}
        end: (?=)|$
        name: meta.property.jsx.protea
        patterns:
          - include: "#style-property-values"
      - include: "#style-selectors"
      - include: "#attribute-names"
      - include: "#comments"
      - include: "#punctuation"

  attribute-names:
    match: \s*([\p{Pd}\w]+)\b\s*
    name: meta.attribute.protea
    captures:
      1:
        name: entity.other.attribute-name.${1:/camelcase}.protea
        patterns:
          - include: "#css-property-names"

  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.protea

  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: {name: punctuation.definition.entity.protea}
          2: {name: punctuation.definition.entity.protea}
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.protea
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.protea
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.protea
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.protea
      - captures: *jsx-entities
        match: (&)(?:\\.|[^({\[)}\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.protea
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.protea

  inline-markdown:
    patterns:
      - include: "#ampersand"
      - include: "#bracket"
      - include: "#bold"
      - include: "#italic"
      - include: "#raw"
      - include: "#escape"
      - include: "#image-inline"
      - include: "#image-ref"
      - include: "#link-email"
      - include: "#link-inet"
      - include: "#link-inline"
      - include: "#link-ref"
      - include: "#link-ref-literal"
      - include: "#link-ref-shortcut"

  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: '&(?!([a-zA-Z0-9]+|#[0-9]+|#x\h+);)'
    name: meta.other.valid-ampersand.markdown

  bold:
    begin: |
      (?x)
      (?<open>(\*\*(?=\w)|(?<!\w)\*\*|(?<!\w)\b__))(?=\S)
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=__\b|\*\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.bold.markdown}
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: "#string-content"
      - include: "#escape"
      - include: "#ampersand"
      - include: "#bracket"
      - include: "#raw"
      - include: "#bold"
      - include: "#italic"
      - include: "#image-inline"
      - include: "#link-inline"
      - include: "#link-inet"
      - include: "#link-email"
      - include: "#image-ref"
      - include: "#link-ref-literal"
      - include: "#link-ref"
      - include: "#link-ref-shortcut"

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    match: \\[-`*_#+.!({\[)}\]\\>]
    name: constant.character.escape.markdown

  image-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.image.markdown}
      8: {name: punctuation.definition.link.markdown}
      9: {name: string.other.link.description.title.markdown}
      10: {name: punctuation.definition.string.markdown}
      11: {name: punctuation.definition.string.markdown}
      12: {name: string.other.link.description.title.markdown}
      13: {name: punctuation.definition.string.markdown}
      14: {name: punctuation.definition.string.markdown}
      15: {name: string.other.link.description.title.markdown}
      16: {name: punctuation.definition.string.markdown}
      17: {name: punctuation.definition.string.markdown}
      18: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)(\S+?)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown

  image-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.begin.markdown}
      5: {name: punctuation.definition.constant.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.markdown}
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns:
      - include: "#string-content"

  italic:
    begin: |
      (?x) (?<open>(\*(?=\w)|(?<!\w)\*|(?<!\w)\b_))(?=\S) # Open
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | \k<open>\k<open> # Must be bold closer
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=_\b|\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.italic.markdown}
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: "#string-content"
      - include: "#escape"
      - include: "#ampersand"
      - include: "#bracket"
      - include: "#raw"
      - include: "#bold"
      - include: "#image-inline"
      - include: "#link-inline"
      - include: "#link-inet"
      - include: "#link-email"
      - include: "#image-ref"
      - include: "#link-ref-literal"
      - include: "#link-ref"
      - include: "#link-ref-shortcut"

  link-email:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      4: {name: punctuation.definition.link.markdown}
    match: (<)((?:mailto:)?[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns:
      - include: "#string-content"

  link-inet:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      3: {name: punctuation.definition.link.markdown}
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns:
      - include: "#string-content"

  link-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.markdown}
      9: {name: punctuation.definition.link.markdown}
      10: {name: string.other.link.description.title.markdown}
      11: {name: punctuation.definition.string.begin.markdown}
      12: {name: punctuation.definition.string.end.markdown}
      13: {name: string.other.link.description.title.markdown}
      14: {name: punctuation.definition.string.begin.markdown}
      15: {name: punctuation.definition.string.end.markdown}
      16: {name: string.other.link.description.title.markdown}
      17: {name: punctuation.definition.string.begin.markdown}
      18: {name: punctuation.definition.string.end.markdown}
      19: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns:
      - include: "#string-content"

  link-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: "#string-content"

  link-ref-literal:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns:
      - include: "#string-content"

  link-ref-shortcut:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      3: {name: punctuation.definition.string.end.markdown}
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: "#string-content"

  raw:
    captures:
      1: {name: punctuation.definition.raw.markdown}
      2: {patterns: [include: "#string-content"]}
      3: {name: punctuation.definition.raw.markdown}
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns:
      - include: "#string-content"

  markdown:
    patterns:
      - include: "#comments"
      - include: "#jsx-entities"
      - include: "#html-tag"
      - include: "#string-content"
      - include: "#evaluated-code"
      - include: "#executed-code"
      - include: "#inline-styles"
      - include: "#blockquote"
      - include: "#unordered-list"
      - include: "#ordered-list"
      - include: "#inline-markdown"

    repository:
      blockquote:
        comment: "> blockquote"
        begin: ^\s*(\>)(\s+.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.quote.begin.markdown}
          2:
            name: markup.quote.markdown
            patterns: [include: "#markdown"]
        name: markup.quote.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.quote.markdown
            patterns: [include: "#markdown"]

      unordered-list:
        comment: "- unordered list"
        begin: ^\s*(\-)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.unnumbered.markdown
            patterns: [include: "#markdown"]
        name: markup.list.unnumbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.unnumbered.markdown
            patterns: [include: "#markdown"]

      ordered-list:
        comment: "+ ordered list"
        begin: ^\s*(\+)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.numbered.markdown
            patterns: [include: "#markdown"]
        name: markup.list.numbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.numbered.markdown
            patterns: [include: "#markdown"]

      evaluated-code:
        applyEndPatternLast: true
        comment: Evaluated code
        begin: (?<=^|[\w\s'"`])(=>)
        end: (?=|$)
        captures:
          1: {name: storage.type.method.protea}
        patterns:
          - include: $self

      executed-code:
        applyEndPatternLast: true
        comment: Executed code
        begin: (?<=^|[\w\s'"`])(->)
        end: (?=|$)
        captures:
          1: {name: storage.type.subroutine.protea}
        patterns:
          - include: $self

      html-tag:
        comment: <Tags
        applyEndPatternLast: true
        begin: (?<=^|[\w\s'"`])(<)\b
        end: (<?>?=?)|(?=)|$
        name: meta.tag.protea
        captures:
          1: {name: punctuation.definition.tag.protea}
        patterns:
          - comment: Tag name
            match: (?<=<)\b([\p{Pc}\p{L}]\w*\b(?:[:.][\p{Pc}\p{L}]\w*)*)\b
            captures:
              1:
                name: entity.name.tag.protea
                patterns: *html-tag-names
          - comment: ID
            match: (?<=#)\b([\p{Pc}\p{L}]\w*)\b
            name: entity.other.attribute-name.id.protea
          - comment: Class
            match: (?<=\.)\b([\p{Pc}\p{L}]\w*)\b
            name: entity.other.attribute-name.class.protea
          - begin: (\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.directive.protea}
            patterns:
          - include: $self
          - begin: (\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.mapping.protea}
            patterns:
              - include: "#style-properties"
              - include: $self
          - begin: (\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.parameters.protea}
            patterns:
              - include: "#tag-attributes"
              - include: $self
          - match: \s*([.#])(?=[\w$])
            name: punctuation.definition.entity.protea
          - comment: inline markup
            begin: (?<!'+)\s*('''+|')
            contentName: string.quoted.single.protea
            end: \s*((\1)(?!'+))
            captures:
              1: {name: punctuation.definition.string.protea}
            patterns: [include: "#markdown"]
          - comment: inline markup
            begin: (?<!"+)\s*("""+|")
            contentName: string.quoted.double.protea
            end: \s*((\1)(?!"+))
            captures:
              1: {name: punctuation.definition.string.protea}
            patterns: [include: "#markdown"]
          - include: "#regexps"

      inline-styles:
        begin: (?<=^|[\w\s'"`])(\+>)(.*)\n*
        beginCaptures:
          1:
            name: storage.type.style.protea
          2:
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: {name: keyword.operator.assignment.protea}
              - include: "#comments"
              - include: "#style-pair"
              - include: "#style-rules"
              - include: "#declaration-clause"
              - match: *entity-name
                name: entity.name.style.protea
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: meta.style.yaml
            patterns: [include: "#style-properties"]

  # Special code blocks

  html-builtins:
    patterns:
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional

  property-name:
    match: \b([\p{Pc}\p{L}]\w*\b(?:(?:::|\.?)[\p{Pc}\p{L}]\w*)*)\b
    name: meta.property-name.protea
    captures:
      1:
        patterns:
          - include: "#css-value-names"
          - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
            name: constant.other.protea
          - match: ([\p{Pc}\p{L}]\w*)\b
            name: constant.language.protea
          - match: '\.|:|::'
            name: punctuation.separator.namespace.protea

  style-list:
    begin: (\[)\s*
    end: \s*(\])
    name: meta.brace.square.protea
    captures:
      1: {name: punctuation.definition.expression.protea}
    patterns:
      - include: "#punctuation"
      - include: "#style-property-values"
      - include: $self

  style-property-values:
    patterns:
      - include: "#style-list"
      - include: "#style-block"
      - include: "#literals"
      - include: "#function-calls"
      - include: "#property-name"
      - include: "#hex-colors"
      - include: "#embedded-expression"
      - include: "#html-builtins"
      - include: "#line-continuation"
      - include: "#jsx"
      - include: "#brackets"

  hex-colors:
    match: (#)\b(?:\h{3,4}|\h{6}|\h{8})\b
    name: constant.other.color.rgb-value.hex.css
    captures:
      1: {name: punctuation.definition.constant.css}

  tag-names:
    match: \s*\b([\p{Pc}\p{L}]\w*\b(?:(?:::|\.?)[\p{Pc}\p{L}]\w*)*)\b\s*
    name: entity.name.tag.protea
    captures:
      1:
        name: entity.name.tag.protea
        patterns: *html-tag-names

  script-block:
    begin: (\{)\s*
    end: \s*(\})
    name: meta.brace.script.protea
    captures:
      1: {name: punctuation.definition.block.script.protea}
    patterns:
      - include: "#interpolated-code"
      - include: source.js
      - include: $self

  style-block:
    begin: (\{)\s*
    end: \s*(\})
    name: meta.brace.style.protea
    captures:
      1: {name: punctuation.section.property-list.protea}
    patterns:
      - include: "#style-properties"

  style-pair:
    applyEndPatternLast: true
    begin: \s*([\p{Pd}\w]+)\b(:)\s*
    end: (?=)|$
    name: meta.property.css.protea
    beginCaptures:
      1:
        name: support.type.property-name.protea
        patterns: [include: "#css-property-names"]
      2:
        name: punctuation.separator.key-value.protea
    patterns:
      - include: "#style-property-values"
      - match: \s+
        name: meta.var.expr.protea

  style-properties:
    patterns:
      - include: "#comments"
      - include: "#embedded"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#style-pair"
      - include: "#style-rules"
      - include: "#style-block"
      - include: $self

  style-rules:
    patterns:
      - comment: CSS operators
        match: \s*(?:(\+)|(\-)|(\*)|(/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|(\#)|([<>]))\s*
        captures:
          1: {name: keyword.operator.sum.protea}
          2: {name: keyword.operator.difference.protea}
          3: {name: keyword.operator.product.protea}
          4: {name: keyword.operator.quotient.protea}
          5: {name: keyword.operator.remainder.protea}
          6: {name: keyword.operator.only.protea}
          7: {name: keyword.operator.maybe.protea}
          8: {name: keyword.operator.intersection.protea}
          9: {name: keyword.operator.union.protea}
          10: {name: keyword.operator.symmetric.protea}
          11: {name: keyword.operator.negation.protea}
          12: {name: keyword.operator.macro.dollar.protea}
          13: {name: keyword.operator.private.protea}
          14: {name: keyword.operator.class.protea}
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.protea
          - include: "#clauses"
          - include: "#constants"
          - include: "#declarations"
          - include: "#expression-keywords"
          - include: "#style-pair"
          - include: "#parameter-variables"
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.selector.protea}
        patterns:
          - include: "#attribute-selectors"
          - include: $self
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|except|only|as)\b\s*
        name: keyword.operator.expression.protea
      - include: "#style-selectors"
      - include: "#format-syntax"
      - include: "#tag-names"

  style-selectors:
    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.protea
      - match: \s*(?<=\@)[\p{Pc}\p{L}]\w*\b\s*
        name: keyword.control.at-rule.protea
      - match: \s*(?<=\#)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.id.protea
      - match: \s*(?<=\.)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.class.protea
      - match: \s*(?<=::)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.pseudo-component.protea
      - match: \s*(?<=\~)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.key.protea
      - match: \s*(?<=\&)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.protea entity.name.type.anchor.protea
      - match: \s*(?<=\*)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.protea entity.name.type.alias.protea
      - match: \s*(?<=\%)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.protea entity.name.function.protea
      - match: \s*(?<=\|)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.protea entity.name.method.protea
      - match: \s*(?<=\:)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.protea entity.name.procedure.protea
      - match: \s*(?<=\^)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.protea entity.name.property.protea
      - match: \s*(?<=\?)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.protea entity.name.predicate.protea

  # Comments

  comments:
    patterns:
      - include: "#block-comments"
      - include: "#line-comments"
      - include: "#nested-comments"

  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.documentation.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-jsdoc"
      - begin: \s*(/\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested-block"

  line-comments:
    patterns:
      - begin: \s*(///)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.documentation.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: \s*(//)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.number-sign.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc:
    begin: (/\*\*?)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.documentation.nested.protea
    captures:
      1: {name: punctuation.definition.comment.protea}
    patterns:
      - include: "#jsdoc"
      - include: text.html.markdown#inline
      - include: "#nested-jsdoc"

  nested-block:
    begin: (/\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.nested.protea
    captures:
      1: {name: punctuation.definition.comment.protea}
    patterns:
      - include: text.html.markdown#inline
      - include: "#nested-block"

  # JSDoc

  jsdoc:
    patterns:
      - include: "#jsdoc-inline-tags"
      - include: "#jsdoc-access"
      - include: "#jsdoc-as-name-path"
      - include: "#jsdoc-simple"
      - include: "#jsdoc-simple-name-path"
      - include: "#jsdoc-module"
      - include: "#jsdoc-type-name"
      - include: "#jsdoc-type-no-name"
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc

  jsdoc-access:
    comment: "@tag protected...."
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}

  jsdoc-module:
    comment: "@tag {optional type} module:file"
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}

  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-name-path-scopes"

  jsdoc-simple:
    comment: "@tag"
    match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}

  jsdoc-simple-name-path:
    comment: "@tag {opt type} Class#xxx or Class#Event:aaaa etc"
    begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|property|this|typedef)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-path-scopes"

  jsdoc-type-name:
    comment: "@tag {optional type} name"
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-scopes"

  jsdoc-type-no-name:
    comment: "@tag {types}"
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"

  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}

  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"

  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}

  jsdoc-typedef-obj:
    comment: typedef object
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - match: \b([\p{Pc}\p{L}]\w*)\b\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"

  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: "#jsdoc-string"
          - include: "#jsdoc-name-scopes"

  jsdoc-name-path-scopes:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}]\w*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.static.jsdoc}
      - match: (\#)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: true
        patterns:
          - include: "#jsdoc-string"

  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  sigil-function-calls:
    name: meta.function.arguments.protea
    match: |
      (?x)
      \b
      (
        (?:
          \b
          [\p{Pc}\p{L}]\w* # identifier
          \b
          (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
        )*
        [\p{Pc}\p{L}]\w* # last part of identifier
      )
      \b
      (?=
        \s*
        (?: # function application, composition and piping
            (?: [$@] | \s\.\s | <\|{1,3} | <[+-]) ['"`({\[\w\s]
          | # C-style function call
            (?:[!?]\.=?|\.=)? \#? [({]
          | # generics
            (?:[!?]\.=?|\.=)? < ['"`({\[\w]
          | # literals
            \w*['"] | `\s*(?=\N)
        )
      )
    captures:
      1: {patterns: [include: "#function-names"]}

  function-calls:
    patterns:
      - name: meta.function.arguments.protea
        match: |
          (?x)
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
                |var|val|let|const|function
                |procedure|method|type|class
                |interface|enum|module|struct
                |protocol|iterator|macro|query
                |object|contract|trait|style|script
                |element|field|model|namespace
                |go|defer|do|with|from|where
                |if|unless|else|then|declare
                |for|foreach|repeat|while|until
                |try|throw|catch|finally|switch
                |match|case|fallthru|default|goto
                |break|continue|redo|retry
                |return|yield|await|scope
                |import|export|route
                |debug|assert|check
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
          (?=
            \s*
            (?: # function application, composition and piping
                (?: [$@] | \s\.\s | <\|{1,3} | <[+-]) ['"`({\[\w\s]
              | # C-style function call
                (?:[!?]\.=?|\.=)? \#? [({]
              | # generics
                (?:[!?]\.=?|\.=)? < ['"`({\[\w]
              | # strings
                \w*['"] | `\s*(?=\N)
            )
          )
        captures:
          1: {patterns: [include: "#function-names"]}
      - name: meta.function.arguments.protea
        match: |
          (?x)
          (?<=
            \s* # opening
            (?:\|{1,3}> | [+-]>) # operator
            \s*
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
                |var|val|let|const|function
                |procedure|method|type|class
                |interface|enum|module|struct
                |protocol|iterator|macro|query
                |object|contract|trait|style|script
                |element|field|model|namespace
                |go|defer|do|with|from|where
                |if|unless|else|then|declare
                |for|foreach|repeat|while|until
                |try|throw|catch|finally|switch
                |match|case|fallthru|default|goto
                |break|continue|redo|retry
                |return|yield|await|scope
                |import|export|route
                |debug|assert|check
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
        captures:
          1: {patterns: [include: "#function-names"]}

  embedded-function-calls:
    name: meta.function.name.protea
    match: |
      (?x)
      (?:
        (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?)) \b
          (?: # Properties
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
          (?= \#? [({] ) # opening bracket
        |
        (?<= ^ # beginning of line
          | ['"`({\[)}\]\w\s] # literal
          (?: # operators
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
          )?
        ) \b
          (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
          (?= \#? [({] ) # opening bracket
      )
    captures:
      1:
        patterns: &builtin-names
          - include: "#type-names"
          - include: "#support-functions"
        name: entity.name.tag.protea
      2:
        patterns: *builtin-names
        name: entity.name.tag.protea support.class.component.protea
      3:
        patterns: *builtin-names
        name: entity.name.class.builtin.protea
      4:
        patterns: *builtin-names
        name: entity.name.function.method.protea
      5:
        patterns: *builtin-names
        name: entity.name.function.tagged-template.protea
      6:
        patterns: *builtin-names
        name: entity.name.type.protea
      7:
        patterns: *builtin-names
        name: entity.name.class.protea
      8:
        patterns: *builtin-names
        name: entity.name.function.protea

  function-names:
    patterns:
      - &function-names
        name: meta.function.name.protea
        match: |
          (?x)
          (?:
            (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?)) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <[-+] | \|{1,3}> | [-+]> | [$@] | \s\.
                  )?
                  ['"`({\[)}\]\w\s]
              )
            |
            (?<=
              (?: ^ | [,;'"`({\[)}\]\w\s] | \\. ) # literal
              (?: # operators
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <[-+] | \|{1,3}> | [-+]> | [$@] | \s\.
                  )?
                  ['"`({\[)}\]\w\s]
              )
          )
        captures:
          1:
            patterns: &builtin-names
              - include: "#type-names"
              - include: "#support-functions"
            name: entity.name.tag.protea
          2:
            patterns: *builtin-names
            name: entity.name.tag.protea support.class.component.protea
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.protea
          4:
            patterns: *builtin-names
            name: entity.name.function.method.protea
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.protea
          6:
            patterns: *builtin-names
            name: entity.name.type.protea
          7:
            patterns: *builtin-names
            name: entity.name.class.protea
          8:
            patterns: *builtin-names
            name: entity.name.function.protea
      - include: "#variables"
      - include: "#primary-operators"

  # Variables

  parameter-variables:
    patterns:
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style|script
                  |element|field|model|namespace|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            [?!] # optional or required
            \b [\p{Pc}\p{L}]\w* \b
            \s*
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.optional.protea
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style|script
                  |element|field|model|namespace|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            \*\*? # spread
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.spread.protea
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style|script
                  |element|field|model|namespace|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            ~~? # named
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.name.protea
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style|script
                  |element|field|model|namespace|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            \& # reference
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.reference.protea
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style|script
                  |element|field|model|namespace|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            \% # other
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.other.protea
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style|script
                  |element|field|model|namespace|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.protea

  placeholder-variables:
    patterns:
      - match: (?i)\s*[?!][\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.optional.protea
      - match: (?i)\s*\*\*?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.spread.protea
      - match: (?i)\s*~~?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.name.protea
      - match: (?i)\s*&[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.protea
      - match: (?i)\s*%[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.other.protea
      - match: (?i)\s*\b[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.protea

  variables:
    patterns:
      - match: |
          (?x)
          (?<=
            \b # qualified name
              [\p{Pc}\p{L}]\w* # identifier
              (?:(?:[?!]?\.|[?!:]:)=?)
            \b
          )
          (?:\d\w+)
        name: variable.other.index.protea
      - comment: |
          Four types of variables:
          - _lead_underscore
          - UPPERCASE
          - PascalCase
          - camelCase
        match: |
          (?x) \b

          (?:
            (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?))
            (?: # Properties
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            |
            (?: # Objects
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            (?=(?:[!?]?\.=?|[?!:]:=?|\s*\#?\[)(?:[,;'"`(){}\[\]\w\s]|$))
            |
            (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
          ) \b
        captures:
          1: {name: variable.other.property.dynamic.protea}
          2: {name: variable.other.constant.property.protea}
          3: {name: variable.other.property.static.protea}
          4: {name: variable.other.property.protea}
          5: {name: variable.other.global.protea}
          6: {name: variable.other.constant.object.protea}
          7: {name: variable.other.class.static.protea}
          8: {name: variable.other.object.protea}
          9: {name: variable.other.dollar.protea}
          10: {name: variable.other.constant.protea}
          11: {name: variable.other.class.protea}
          12: {name: variable.other.readwrite.protea}

  # Operators

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#infix-operators"
      - include: "#primary-operators"
      - include: "#suffix-operators"
      - include: "#prefix-operators"

  special-operators:
    patterns:
      - comment: "? ternary operator"
        begin: (?<=^|[\s({\[])(\?)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\?)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.conditional.protea}
          2: {name: keyword.operator.conditional.protea}
        patterns:
          - include: $self
      - comment: "! ternary operator"
        begin: (?<=^|[\s({\[])(\!)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\!)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.ternary.protea}
          2: {name: keyword.operator.ternary.protea}
        patterns:
          - include: $self

  infix-operators:
    patterns:
      - name: keyword.operator.infix.protea
        match: |
          (?xi)
          (?<=^|[\s({\[]) # opening
          (?:
            ( # 1: compound assignment operators
              # all operators except ~ < = > . : !
              [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
              # operator character
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
              = # ending equal sign
            ) |
            ( # 2: arithmetic operator
              \+ | - | \*{1,3} | //? | %%?
            ) |
            ( # 3: string / regex
              \+\+ | --
            ) |
            ( # 4: logical operator
              \&\& | \|\| | \^\^ | ! | /\\ | \\/
            ) |
            ( # 5: bitwise and set
              \& | \| | \^ | ~
            ) |
            ( # 6: bitwise shift
              <<<? | >>>?
            ) |
            ( # 7: pipeline
              <\|{1,3} | \|{1,3}>
            ) |
            ( # 8: composition
              <\+ | \+>
            ) |
            ( # 9: membership
              [<>][:!] | [:!][<>]
            ) |
            ( # 10: comparison
              < | > | <= | >= | <> | <=>
            ) |
            ( # 11: equality
              == | != | === | !==
            ) |
            ( # 12: similarity
              ~[=!] | [=!]~ | =<
            ) |
            ( # 13: functional
              <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
            ) |
            ( # 14: null coalescing
              \?+
            ) |
            ( # 15: non null coalescing
              !+
            ) |
            ( # 16: falsy coalescing
              \?:
            ) |
            ( # 17: truthy coalescing
              !:
            ) |
            ( # 18: function application
              [.$]
            ) |
            ( # 19: assignment
              :?=
            ) |
            ( # 20: range
              [>.]\.[.<] | \.\. | [=.]\.[.=]
            ) |
            ( # 21: fat arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* => # right side
              | <= [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 22: skinny arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* -> # right side
              | <- [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 23: wavy arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* ~> # right side
              | <~ [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 24: custom logical
              [&|^~] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 25: custom arithmetic
              [-+*/%] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 26: custom prototype
              [@:] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 27: custom accessor
              [.] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 28: custom comparison
              [=!] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 29: custom relational
              [<>] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 30: custom private
              [?\#] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 31: custom math
              \p{Sm} # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 32: custom currency
              \p{Sc} # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 33: custom ascii
              [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 34: catch all
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
          )
          (?=$|[)}\]\s]) # closing
        captures:
          1: {name: keyword.operator.assignment.augmented.protea}
          2: {name: keyword.operator.arithmetic.protea}
          3: {name: keyword.operator.successor.protea}
          4: {name: keyword.operator.logical.protea}
          5: {name: keyword.operator.bitwise.protea}
          6: {name: keyword.operator.bitwise.shift.protea}
          7: {name: keyword.operator.pipeline.protea}
          8: {name: keyword.operator.compose.protea}
          9: {name: keyword.operator.class.protea}
          10: {name: keyword.operator.relational.protea}
          11: {name: keyword.operator.comparison.protea}
          12: {name: keyword.operator.similarity.protea}
          13: {name: keyword.operator.function.protea}
          14: {name: keyword.operator.null-coalescing.protea}
          15: {name: keyword.operator.coalescing.protea}
          16: {name: keyword.operator.conditional.protea}
          17: {name: keyword.operator.ternary.protea}
          18: {name: keyword.operator.macro.protea}
          19: {name: keyword.operator.assignment.protea}
          20: {name: keyword.operator.range.protea}
          21: {name: keyword.operator.arrow.fat.protea}
          22: {name: keyword.operator.arrow.skinny.protea}
          23: {name: keyword.operator.arrow.wavy.protea}
          24: {name: keyword.operator.logical.custom.protea}
          25: {name: keyword.operator.arithmetic.custom.protea}
          26: {name: keyword.operator.prototype.custom.protea}
          27: {name: keyword.operator.accessor.custom.protea}
          28: {name: keyword.operator.comparison.custom.protea}
          29: {name: keyword.operator.relational.custom.protea}
          30: {name: keyword.operator.private.custom.protea}
          31: {name: keyword.operator.math.custom.protea}
          32: {name: keyword.operator.currency.custom.protea}
          33: {name: keyword.operator.ascii.custom.protea}
          34: {name: keyword.operator.infix.protea}

  primary-operators:
    patterns:
      - name: keyword.operator.primary.protea
        match: |
          (?x)
          (?<=['"`)}\]\w]|\\.) # closing
          (?:
            ( # 1: optional accessor
            \?[.:]=?
            ) |
            ( # 2: assertion/call operator
              ![.:]=?
            ) |
            ( # 3: accessor operator
              (?:::|\.)=?
            ) |
            ( # 4: compound assignment operators
              # all operators except ~ < = > . : !
              [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
              # operator character
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
              = # ending equal sign
            ) |
            ( # 5: arithmetic operator
              \+ | - | \*{1,3} | //? | %%?
            ) |
            ( # 6: string / regex
              \+\+ | --
            ) |
            ( # 7: logical operator
              \&\& | \|\| | \^\^ | ! | /\\ | \\/
            ) |
            ( # 8: bitwise and set
              \& | \| | \^ | ~
            ) |
            ( # 9: bitwise shift
              <<<? | >>>?
            ) |
            ( # 10: pipeline
              <\|{1,3} | \|{1,3}>
            ) |
            ( # 11: composition
              <\+ | \+>
            ) |
            ( # 12: membership
              [<>][:!] | [:!][<>]
            ) |
            ( # 13: comparison
              < | > | <= | >= | <> | <=>
            ) |
            ( # 14: equality
              == | != | === | !==
            ) |
            ( # 15: similarity
              ~[=!] | [=!]~ | =<
            ) |
            ( # 16: functional
              <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
            ) |
            ( # 17: null coalescing
              \?+
            ) |
            ( # 18: non null coalescing
              !+
            ) |
            ( # 19: falsy coalescing
              \?:
            ) |
            ( # 20: truthy coalescing
              !:
            ) |
            ( # 21: function application
              [.$]
            ) |
            ( # 22: assignment
              :?=
            ) |
            ( # 23: range
              [>.]\.[.<] | \.\. | [=.]\.[.=]
            ) |
            ( # 24: fat arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* => # right side
              | <= [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 25: skinny arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* -> # right side
              | <- [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 26: wavy arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* ~> # right side
              | <~ [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 27: custom logical
              [&|^~] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 28: custom arithmetic
              [-+*/%] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 29: custom prototype
              [@:] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 30: custom accessor
              [.] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 31: custom comparison
              [=!] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 32: custom relational
              [<>] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 33: custom private
              [?\#] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 34: custom math
              \p{Sm} # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 35: custom currency
              \p{Sc} # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 36: custom ascii
              [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 37: catch all
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
          )
          (?=['"`({\[\w]) # opening
        captures:
          1: {name: keyword.operator.optional.protea}
          2: {name: keyword.operator.assert.protea}
          3: {name: keyword.operator.accessor.protea}
          4: {name: keyword.operator.assignment.augmented.protea}
          5: {name: keyword.operator.arithmetic.protea}
          6: {name: keyword.operator.successor.protea}
          7: {name: keyword.operator.logical.protea}
          8: {name: keyword.operator.bitwise.protea}
          9: {name: keyword.operator.bitwise.shift.protea}
          10: {name: keyword.operator.pipeline.protea}
          11: {name: keyword.operator.compose.protea}
          12: {name: keyword.operator.class.protea}
          13: {name: keyword.operator.relational.protea}
          14: {name: keyword.operator.comparison.protea}
          15: {name: keyword.operator.similarity.protea}
          16: {name: keyword.operator.function.protea}
          17: {name: keyword.operator.null-coalescing.protea}
          18: {name: keyword.operator.coalescing.protea}
          19: {name: keyword.operator.conditional.protea}
          20: {name: keyword.operator.ternary.protea}
          21: {name: keyword.operator.macro.protea}
          22: {name: keyword.operator.assignment.protea}
          23: {name: keyword.operator.range.protea}
          24: {name: keyword.operator.arrow.fat.protea}
          25: {name: keyword.operator.arrow.skinny.protea}
          26: {name: keyword.operator.arrow.wavy.protea}
          27: {name: keyword.operator.logical.custom.protea}
          28: {name: keyword.operator.arithmetic.custom.protea}
          29: {name: keyword.operator.prototype.custom.protea}
          30: {name: keyword.operator.accessor.custom.protea}
          31: {name: keyword.operator.comparison.custom.protea}
          32: {name: keyword.operator.relational.custom.protea}
          33: {name: keyword.operator.private.custom.protea}
          34: {name: keyword.operator.math.custom.protea}
          35: {name: keyword.operator.currency.custom.protea}
          36: {name: keyword.operator.ascii.custom.protea}
          37: {name: keyword.operator.primary.protea}

  prefix-operators:
    comment: Prefix operators
    match: |
      (?x)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 15
      (?=[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
      ['"`({\[\w])
    name: keyword.operator.prefix.protea
    captures:
      1: {name: keyword.operator.module.all.protea}
      2: {name: keyword.operator.increment.protea}
      3: {name: keyword.operator.decrement.protea}
      4: {name: keyword.operator.intersection.protea}
      5: {name: keyword.operator.union.protea}
      6: {name: keyword.operator.symmetric.protea}
      7: {name: keyword.operator.logical.protea}
      8: {name: keyword.operator.private.protea}
      9: {name: keyword.operator.decorator.protea}
      10: {name: keyword.operator.bitwise.not.protea}
      11: {name: keyword.operator.existential.protea}
      12: {name: keyword.operator.assignment.protea}
      13: {name: keyword.operator.pipeline.protea}
      14: {name: keyword.operator.private.protea}
      15: {name: keyword.operator.prefix.protea}

  suffix-operators:
    comment: Suffix operators
    match: |
      (?x)
      (?<=(?:['"`)}\]\w]|\\.)
        [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 15
    name: keyword.operator.suffix.protea
    captures:
      1: {name: keyword.operator.module.all.protea}
      2: {name: keyword.operator.increment.protea}
      3: {name: keyword.operator.decrement.protea}
      4: {name: keyword.operator.intersection.protea}
      5: {name: keyword.operator.union.protea}
      6: {name: keyword.operator.symmetric.protea}
      7: {name: keyword.operator.assert.protea}
      8: {name: keyword.operator.private.protea}
      9: {name: keyword.operator.decorator.protea}
      10: {name: keyword.operator.bitwise.protea}
      11: {name: keyword.operator.optional.protea}
      12: {name: keyword.operator.assignment.protea}
      13: {name: keyword.operator.pipeline.protea}
      14: {name: keyword.operator.private.protea}
      15: {name: keyword.operator.suffix.protea}

  # Clauses and Keywords

  parameter-brackets:
    begin: (\()\s*
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.protea}
    patterns:
      - include: "#binding-pattern"
      - include: $self

  modifier-keywords:
    name: storage.modifier.protea
    match: |
      (?x)
      (
        (?:
          (?:
            \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)
            \b
              (?:
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|opaque|transparent|inline
                |prefix|infix|suffix|unary|left|right
              )
            )
            \b
          \s*
        )*
      )
      (?=
        \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?:
          var|val|let|const|function
          |procedure|method|type|class
          |interface|enum|module|struct
          |protocol|iterator|macro|query
          |object|contract|trait|style|script
          |element|field|model|namespace
        )
        \b
      )
    captures:
      1:
        patterns:
          - include: "#modifiers"

  modifiers:
    patterns:
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            public|private|protected|final|readonly|override
            |global|local|intern|extern|implicit|explicit
            |post|get|set|put|delete|required|optional
            |checked|unchecked|delegate|safe|unsafe|virtual
          )
          \b
          \s*
        name: storage.modifier.protea
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            sealed|abstract|impure|pure|early|late
            |covar|contra|a?sync|static|dynamic|lazy
            |eager|bound|free|unique|struct|union
            |changed|unchanged|open|opened|closed?
          )
          \b
          \s*
        name: storage.modifier.declaration.protea
      - comment: Functional modifiers
        match: |
          (?x) \s*
          \b
          (?:
            recursive|operator|curried|opaque|transparent|inline
            |prefix|infix|suffix|unary|left|right
          )
          \b
          \s*
        name: storage.modifier.function.protea

  declaration-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(declare)\b\s*
        name: keyword.other.declare.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)\b\s*
        name: storage.type.protea
      - match: |
          (?x)
          \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style|script
              |element|field|model|namespace
            )
            \b
          \s*
        name: storage.type.$1.protea

  general-keywords:
    comment: general keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|unless|else)\b\s*
        name: keyword.control.conditional.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|foreach|repeat|while|until)\b\s*
        name: keyword.control.loop.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|finally|then)\b\s*
        name: keyword.control.trycatch.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch|case|default)\b\s*
        name: keyword.control.switch.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|continue|redo|retry|return|await|scope|yield|goto|fallthru)\b\s*
        name: keyword.control.flow.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|route)\b\s*
        name: keyword.control.module.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|do|from|ref|go|defer)\b\s*
        name: keyword.control.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|check|where)\b\s*
        name: keyword.other.$1.protea

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new)\b\s*
        name: keyword.operator.expression.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(delete)\b\s*
        name: keyword.operator.expression.delete.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|till|thru|by)\b\s*
        name: keyword.operator.expression.range.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)\b\s*
        name: keyword.operator.expression.void.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(and|or|xor|not)\b\s*
        name: keyword.operator.expression.logical.protea

  keywords:
    patterns:
      - include: "#modifier-keywords"
      - include: "#constraint-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#query-expression"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

  control-expression:
    applyEndPatternLast: true
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|continue|redo|retry|scope|goto|fallthru)\b\s*
    end: (?=)|$
    beginCaptures:
      1: {name: keyword.control.flow.protea}
    patterns:
      - match: *entity-name
        name: constant.other.label.protea

  module-expression:
    patterns:
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|route)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.control.module.protea}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|as|only|except|default)\b\s*
            name: keyword.control.module.protea
          - include: "#module-content"

    repository:
      module-content:
        patterns:
          - begin: ({)\s*
            end: \s*(})
            captures:
              1: {name: punctuation.definition.block.protea}
            patterns:
              - include: "#module-content"
              - include: "#illegal"
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.control.module.protea
          - include: "#type-keywords"
          - include: "#strings"
          - include: "#regexps"
          - include: "#symbols"
          - match: \s*(?<!\*)\*(?!\*)\s*
            name: constant.language.import-export-all.js
          - include: "#modifiers"
          - include: "#comma"
          - include: "#line-continuation"
          - match: *entity-name
            name: variable.other.readwrite.alias.protea

  constraint-expression:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)\b\s*
    beginCaptures:
      1: {name: keyword.control.validate.protea}
    end: (?=[,;)}\]])
    patterns:
      - match: &constraint-keyword |
          (?x)
          \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
              (?:
                require|ensure|(de|in)(crease|crement)|throw|read|assume
                |return|yield|varie|change|create|alter|delete|drop|rename
                |reveal|write|name|permit|allow|grant|revoke|deny|disallow
                |modifie|renew|transfer|postpone|suspend|resume|abort|reject
                |cancel|post|put|get|set|patch|delete|trace|connect|disconnect
                |accept|receive|send|open|close|lock|unlock|flush|reboot|reload
                |restart|start|stop|kill|spawn|invoke|execute|derive|connect
                |extend|implement|use
              )s
            )
            \b\s*
          \s*
        name: keyword.control.validate.protea
      - include: $self

  query-expression:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)\b\s*
    beginCaptures:
      1: {name: keyword.control.query.protea}
    end: (?=[,;)}\]])
    patterns:
      - include: "#query-body"
      - include: $self

  query-body:
    patterns:
      - include: "#in-clause"
      - include: "#where-clause"
      - include: "#join-clause"
      - include: "#sort-clause"
      - include: "#select-clause"
      - include: "#group-clause"
      - include: "#limit-clause"
      - include: "#reduce-clause"

    repository:
      in-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              in|of
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.protea}
        end: (?=[,;)}\]])
        patterns:
          - include: "#query-body"
          - include: $self

      join-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:full|part|self|cross)? \b \s*
              \b (?:inner|outer|left|right)? \b \s*
              \b (?:join)
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.protea}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b([io]nto|equal|in|of)\b\s*
            name: keyword.control.query.protea
          - include: "#query-body"
          - include: $self

      where-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              where|having|filter|reject
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
        end: (?=[,;)}\]])
        patterns:
          - include: "#query-body"
          - include: $self

      sort-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:sort|order) \b \s*
              \b (?:asc|desc)? \b \s*
              \b (?:by|with)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
        end: (?=[,;)}\]])
        patterns:
          - include: "#query-body"
          - include: $self

      select-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:select|map) \b \s*
              \b (?:unique|any|all|some|every)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
            name: keyword.control.query.protea
          - include: "#query-body"
          - include: $self

      limit-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:take|drop|limit|offset) \b \s*
              \b (?:first|last|head|tail)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
            name: keyword.control.query.protea
          - include: "#query-body"
          - include: $self

      reduce-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:fold|reduce|scan) \b \s*
              \b (?:first|last|left|right)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
            name: keyword.control.query.protea
          - include: "#query-body"
          - include: $self

      group-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              group
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|[io]nto)\b\s*
            name: keyword.control.query.protea
          - include: "#query-body"
          - include: $self

  declarations:
    patterns:
      - include: "#variable"
      - include: "#declare"
      - include: "#style"
      - include: "#script"
      - include: "#markup"
      - include: "#function"
      - include: "#procedure"
      - include: "#method"
      - include: "#class"
      - include: "#interface"
      - include: "#enum"
      - include: "#module"
      - include: "#iterator"
      - include: "#macro"
      - include: "#query"
      - include: "#object"
      - include: "#trait"
      - include: "#component"
      - include: "#field"
      - include: "#contract"
      - include: "#struct"
      - include: "#protocol"
      - include: "#model"
      - include: "#namespace"

    repository:
      style:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.style.protea}
        name: meta.style.protea
        patterns:
          - include: "#style-rules"
          - include: "#style-pair"
          - include: "#style-block"
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.style.protea

      script:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(script)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.script.protea}
        name: meta.script.protea
        patterns:
          - include: "#script-block"
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.script.protea

      component:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(element)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.component.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.component.protea
            patterns: *html-tag-names

      variable:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.variable.protea}

      declare:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(declare)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.other.declare.protea}

      function:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(function)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.function.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.function.protea

      namespace:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(namespace)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.namespace.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.namespace.protea

      method:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(method)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.method.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.method.protea

      procedure:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(procedure)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.procedure.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.procedure.protea

      class:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.class.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.class.protea

      interface:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(interface)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.interface.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.interface.protea

      enum:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.enum.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.enum.protea

      module:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.module.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.module.protea

      iterator:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iterator)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.iterator.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.iterator.protea

      model:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(model)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.model.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.model.protea

      macro:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.macro.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.macro.protea

      query:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(query)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.query.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.query.protea

      object:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.object.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.object.protea

      trait:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.trait.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.trait.protea

      contract:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(contract)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.contract.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.contract.protea

      protocol:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(protocol)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.protocol.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.protocol.protea

      struct:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.struct.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.struct.protea

      field:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(field)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.field.protea}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.field.protea

  declaration-clause:
    name: meta.declaration.protea
    patterns:
      - match: *constraint-keyword
        name: keyword.other.$1.protea
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=::|\.)
        name: entity.name.namespace.protea
      - include: "#type-square-brackets"
      - include: "#type-signature"
      - include: "#decorators"
      - include: "#type-keywords"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.protea
      - include: "#comments"
      - include: "#comma"
      - include: "#line-continuation"
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - include: "#binding-pattern"
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.section.class.protea}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.block.protea}
        patterns:
          - include: $self
      - include: "#brackets"
      - include: "#literals"
      - match: ::|\.
        name: punctuation.separator.namespace.protea
      - match: \s+
        name: meta.block.protea

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|opaque|transparent|inline
                |prefix|infix|suffix|unary|left|right
              )
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|procedure|method|type
              |class|interface|enum|module|struct|protocol
              |iterator|macro|query|object|contract
              |trait|style|script|element|field|model|namespace
            )
            \b
          )
        name: meta.function.declaration.protea
        captures:
          1: {name: entity.name.method.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: [include: "#modifier-keywords"]}
      - begin: |
          (?x)

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|opaque|transparent|inline
                |prefix|infix|suffix|unary|left|right
              )
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.protea
        captures:
          1: {name: entity.name.method.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: [include: "#modifier-keywords"]}
          4: {name: punctuation.separator.arguments.protea}
        endCaptures:
          1: {name: punctuation.separator.arguments.protea}
        patterns:
          - include: "#argument-list-content"
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|opaque|transparent|inline
                |prefix|infix|suffix|unary|left|right
              )
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|procedure|method|type
              |class|interface|enum|module|struct|protocol
              |iterator|macro|query|object|contract
              |trait|style|script|element|field|model|namespace
            )
            \b
          )
        name: meta.function.declaration.protea
        captures:
          1: {name: entity.name.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: [include: "#modifier-keywords"]}
      - begin: |
          (?x)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          \s*

          (
            (?:
              \s*
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|opaque|transparent|inline
                |prefix|infix|suffix|unary|left|right
              )
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.protea
        captures:
          1: {name: entity.name.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: [include: "#modifier-keywords"]}
          4: {name: punctuation.separator.arguments.protea}
        endCaptures:
          1: {name: punctuation.separator.arguments.protea}
        patterns:
          - include: "#argument-list-content"

  argument-list:
    name: meta.function.arguments.protea
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style|script
              |element|field|model|namespace
              |go|defer|do|with|from|where
              |if|unless|else|then|declare
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (\|)(?!\|)
    captures:
      1: {name: punctuation.separator.arguments.protea}
    end: (?<!\|)(\|)(?!\|)
    patterns:
      - include: "#argument-list-content"

  argument-list-content:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
        name: keyword.operator.expression.as.protea
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.protea
      - match: ","
        name: punctuation.separator.arguments.protea
      - include: "#binding-pattern"

  clauses:
    patterns:
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#match-clause"
      - include: "#switch-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#do-clause"
      - include: "#type-clause"
      - include: "#new-clause"

    repository:
      new-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)\b
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.protea}
        patterns:
          - match: *entity-name
            name: entity.name.instance.protea
          - include: "#type-clause"
          - include: "#type-keywords"
          - include: "#type-square-brackets"
          - include: "#parameter-brackets"
          - include: "#round-brackets"

      type-clause:
        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)\b\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.protea}
            patterns:
              - include: "#types"
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)\b\s*
            end: (?=)|$
            captures:
              1: {name: keyword.other.typedef.protea}
            patterns:
              - include: "#types"
              - match: \s*([?:]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.protea}

      catch-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(catch)\b\s*(?=\()
        end: (?=)|$
        name: meta.catch.protea
        captures:
          1: {name: keyword.control.error.protea}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
                name: keyword.control.error.protea
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.protea}
            patterns:
              - include: "#catch-case-clause"
              - include: $self

      catch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(default)\b\s*(:)
            captures:
              1: {name: keyword.control.error.protea}
              2: {name: punctuation.definition.case-statement.protea}
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.error.protea}
            endCaptures:
              1: {name: punctuation.definition.case-statement.protea}
            patterns:
              - include: "#argument-list"
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.error.protea}
                patterns:
                  - include: "#types"
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|as)\b\s*
                name: keyword.control.error.protea
              - include: "#type-keywords"
              - include: $self

      for-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|foreach|while|until)\b\s*(?=\()
        end: (?=)|$
        name: meta.for.protea
        captures:
          1: {name: keyword.control.loop.protea}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)\b\s*
                name: keyword.control.loop.protea
              - include: $self

      if-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|unless)\b\s*(?=\()
        end: (?=)|$
        name: meta.if.protea
        captures:
          1: {name: keyword.control.conditional.protea}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.conditional.protea
              - include: $self

      match-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)\b\s*(?=\()
        end: (?=)|$
        name: meta.match.protea
        captures:
          1: {name: keyword.control.match.protea}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.match.protea
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.protea}
            patterns:
              - include: "#match-case-clause"
              - include: $self

      switch-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch)\b\s*(?=\()
        end: (?=)|$
        name: meta.switch.protea
        captures:
          1: {name: keyword.control.switch.protea}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.switch.protea
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.protea}
            patterns:
              - include: "#switch-case-clause"
              - include: $self

      switch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(default)\b\s*(:)
            captures:
              1: {name: keyword.control.switch.protea}
              2: {name: punctuation.definition.case-statement.protea}
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.switch.protea}
            endCaptures:
              1: {name: punctuation.definition.case-statement.protea}
            patterns:
              - include: "#argument-list"
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.switch.protea}
                patterns:
                  - include: "#types"
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|as)\b\s*
                name: keyword.control.switch.protea
              - include: "#type-keywords"
              - include: $self

      match-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(default)\b\s*(:)
            captures:
              1: {name: keyword.control.match.protea}
              2: {name: punctuation.definition.case-statement.protea}
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.match.protea}
            endCaptures:
              1: {name: punctuation.definition.case-statement.protea}
            patterns:
              - include: "#argument-list"
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.match.protea}
                patterns:
                  - include: "#types"
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|as)\b\s*
                name: keyword.control.match.protea
              - include: "#type-keywords"
              - include: $self

      with-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)\b\s*(?=\()
        end: (?=)|$
        name: meta.with.protea
        captures:
          1: {name: keyword.control.with.protea}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await|as)\b\s*
                name: keyword.control.with.protea
              - include: $self

  # Binding patterns

  object-key:
    begin: (?<=^|{|;|,)\s*
    end: \s*(?=,|;|}|$)|\s*(:)
    name: meta.object-key.protea
    endCaptures:
      1: {name: punctuation.separator.key-value.protea}
    patterns:
      - include: "#literals"
      - include: "#embedded-expression"
      - include: "#brackets"
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|:|$)
        name: constant.other.object.key.protea
      - include: "#space"
      - include: "#comments"
      - include: "#line-continuation"
      - include: $self

  object-value:
    match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|=['"`({\[\w\s]|$)
    name: variable.other.constant.protea

  object-argument:
    match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|=['"`({\[\w\s]|$)
    name: variable.parameter.named.protea

  as-keyword:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
    name: keyword.operator.expression.as.protea

  binding-pattern-object:
    begin: (#?{)\s*
    end: \s*(})
    name: meta.brace.curly.protea
    captures:
      1: {name: punctuation.definition.binding-pattern.object.protea}
    patterns:
      - include: "#object-argument"
      - include: "#labels"
      - include: "#object-key"
      - match: ;|,
        name: punctuation.separator.mapping.protea
      - include: "#binding-pattern"
      - include: "#illegal"

  binding-pattern-tuple:
    begin: (#?\()\s*
    end: \s*(\))
    name: meta.brace.curly.protea
    captures:
      1: {name: punctuation.definition.binding-pattern.tuple.protea}
    patterns:
      - include: "#labels"
      - match: ;|,
        name: punctuation.separator.arguments.protea
      - include: "#binding-pattern"
      - include: "#illegal"

  binding-pattern-array:
    begin: (#?\[)\s*
    end: \s*(])
    name: meta.brace.curly.protea
    captures:
      1: {name: punctuation.definition.binding-pattern.array.protea}
    patterns:
      - include: "#labels"
      - match: ;|,
        name: punctuation.separator.sequence.protea
      - include: "#binding-pattern"
      - include: "#illegal"

  default-value:
    begin: (?<=^|[\s({\[])(\=)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\=)(?=['"`({\[\w])
    captures:
      1: {name: keyword.operator.assignment.protea}
      2: {name: keyword.operator.assignment.protea}
    end: (?=\|(?:$|[^|])|[,;)}\]])
    patterns:
      - include: $self

  binding-pattern:
    patterns:
      - include: "#default-value"
      - include: "#as-keyword"
      - include: "#binding-pattern-object"
      - include: "#binding-pattern-tuple"
      - include: "#binding-pattern-array"
      - include: "#illegal-identifiers"
      - include: "#parameter-variables"
      - include: "#type-operators"
      - include: "#type-signature"
      - include: "#space"
      - include: "#comments"
      - include: "#calls"

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)\s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|opaque|transparent|inline
                |prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|procedure|method|type
              |class|interface|enum|module|struct|protocol
              |iterator|macro|query|object|contract
              |trait|style|script|element|field|model|namespace
            )
            \b
          )
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.protea}
          2: {name: punctuation.separator.key-value.protea}
          3: {name: storage.modifier.protea}
      - begin: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)

          \s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|opaque|transparent|inline
                |prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.protea
        beginCaptures:
          1: {name: entity.name.protea}
          2: {name: punctuation.separator.key-value.protea}
          3: {name: storage.modifier.protea}
          4: {name: punctuation.separator.arguments.protea}
        endCaptures:
          1: {name: punctuation.separator.arguments.protea}
        patterns:
          - include: "#argument-list-content"
      - match: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*

          # label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)

          (?=: ['"`({\[)}\]\w\s])
        name: meta.object-literal.key.protea
        captures:
          1:
            name: constant.other.object.key.protea
            patterns:
              - include: "#constants"
              - include: "#numbers"
              - include: "#symbols"
              - include: "#string-content"

  # Punctuation

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#semicolon"

  line-continuation:
    begin: \s*(`)\s*(?=/[/*](?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)|$)
    end: ^\s*(?=\S)
    captures:
      1: {name: punctuation.separator.continuation.line.protea}
    patterns:
      - include: "#comments"
  comma:
    match: \s*(,)
    name: punctuation.separator.expression.protea
  double-semicolon:
    match: \s*(;;)
    name: punctuation.terminator.expression.protea
  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.protea

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"
      - include: "#angle-brackets"

  angle-brackets:
    patterns:
      - comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        name: meta.type-arguments
        begin: (?<=^|['"`)}\]\w\s])(<)(?=['"`({\[\w])
        end: (?<=^|['"`)}\]>\w])(>)
        captures:
          1: {name: punctuation.type.arguments.protea}
        patterns:
          - include: "#punctuation"
          - include: "#brackets"
          - include: "#types"
          - include: "#type-signature"

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.protea
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.protea

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.binding-pattern.object.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: "#as-keyword"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.dictionary.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s+\|
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.section.class.protea}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s+\|
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.block.protea}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.dictionary.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.section.class.protea}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: {name: punctuation.definition.block.protea}
        patterns:
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.protea
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.protea

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.protea}
        patterns:
          - include: "#as-keyword"
          - include: "#punctuation"
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: {name: punctuation.definition.tuple.protea}
        patterns:
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: {name: punctuation.definition.expression.protea}
        patterns:
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.sequence.protea

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.binding-pattern.array.protea}
        patterns:
          - include: "#punctuation"
          - include: "#as-keyword"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.sequence.protea}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.array.protea}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.attribute-selector.protea}
        patterns:
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.sequence.protea}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: {name: punctuation.definition.array.protea}
        patterns:
          - include: "#punctuation"
          - include: $self

  # Support

  css-property-names:
    patterns:
      - match: (?x)\b(additiveSymbols|alignContent|alignItems|alignSelf|all|animation|animationDelay|animationDirection|animationDuration|animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|backdropFilter|backfaceVisibility|background|backgroundAttachment|backgroundBlendMode|backgroundClip|backgroundColor|backgroundImage|backgroundOrigin|backgroundPosition|backgroundPosition[XY]|backgroundRepeat|backgroundSize|bleed|blockSize|border|borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor|borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius|borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage|borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd|borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor|borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth|borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius|borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle|borderTopWidth|borderWidth|bottom|boxDecorationBreak|boxShadow|boxSizing|breakAfter|breakBefore|breakInside|captionSide|caretColor|clear|clip|clipPath|clipRule|color|colorAdjust|colorInterpolationFilters|columnCount|columnFill|columnGap|columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columnSpan|columnWidth|columns|contain|content|counterIncrement|counterReset|cursor|direction|display|emptyCells|enableBackground|fallback|fill|fillOpacity|fillRule|filter|flex|flexBasis|flexDirection|flexFlow|flexGrow|flexShrink|flexWrap|float|floodColor|floodOpacity|font|fontDisplay|fontFamily|fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures|fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyphOrientationHorizontal|glyphOrientationVertical|grid|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumnStart|gridGap|gridRow|gridRowEnd|gridRowGap|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows|hangingPunctuation|height|hyphens|imageOrientation|imageRendering|imageResolution|imeMode|initialLetter|initialLetterAlign|inlineSize|inset|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation|justifyContent|justifyItems|justifySelf|kerning|left|letterSpacing|lightingColor|lineBreak|lineClamp|lineHeight|listStyle|listStyleImage|listStylePosition|listStyleType|margin|marginBlockEnd|marginBlockStart|marginBottom|marginInlineEnd|marginInlineStart|marginLeft|marginRight|marginTop|markerEnd|markerMid|markerStart|marks|mask|maskBorder|maskBorderMode|maskBorderOutset|maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode|maskOrigin|maskPosition|maskRepeat|maskSize|maskType|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth|maxZoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mixBlendMode|negative|objectFit|objectPosition|offset|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|orientation|orphans|outline|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflowAnchor|overflowBlock|overflowInline|overflowWrap|overflow-[xy]|overscrollBehavior|overscrollBehaviorBlock|overscrollBehaviorInline|overscrollBehavior-[xy]|pad|padding|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInlineEnd|paddingInlineStart|paddingLeft|paddingRight|paddingTop|pageBreakAfter|pageBreakBefore|pageBreakInside|paintOrder|perspective|perspectiveOrigin|placeContent|placeItems|placeSelf|pointerEvents|position|prefix|quotes|range|resize|right|rotate|rowGap|rubyAlign|rubyMerge|rubyPosition|scale|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart|scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight|scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom|scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight|scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType|scrollbarColor|scrollbarGutter|scrollbarWidth|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size|speakAs|src|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|suffix|symbols|system|tabSize|tableLayout|textAlign|textAlignLast|textAnchor|textCombineUpright|textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle|textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textIndent|textJustify|textOrientation|textOverflow|textRendering|textShadow|textSizeAdjust|textTransform|textUnderlinePosition|top|touchAction|transform|transformBox|transformOrigin|transformStyle|transition|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction|translate|unicodeBidi|unicodeRange|userSelect|userZoom|verticalAlign|visibility|whiteSpace|widows|width|willChange|wordBreak|wordSpacing|wordWrap|writingMode|zIndex|zoom|alignmentBaseline|baselineShift|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|cx|cy|dominantBaseline|enableBackground|fill|fillOpacity|fillRule|floodColor|floodOpacity|glyphOrientationHorizontal|glyphOrientationVertical|height|kerning|lightingColor|markerEnd|markerMid|markerStart|r|rx|ry|shapeRendering|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|textAnchor|width|x|y|adjust|after|align|alignLast|alignment|alignmentAdjust|appearance|attachment|azimuth|backgroundBreak|balance|baseline|before|bidi|binding|bookmark|bookmarkLabel|bookmarkLevel|bookmarkTarget|borderLength|bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|boxAlign|boxDirection|boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|break|character|collapse|column|columnBreakAfter|columnBreakBefore|count|counter|crop|cue|cueAfter|cueBefore|decoration|decorationBreak|delay|displayModel|displayRole|down|drop|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust|dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|family|fit|fitPosition|flexGroup|floatOffset|gap|gridColumns|gridRows|hangingPunctuation|header|hyphenate|hyphenateAfter|hyphenateBefore|hyphenateCharacter|hyphenateLines|hyphenateResource|icon|image|increment|indent|index|initialAfterAdjust|initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialSize|initialValue|inlineBoxAlign|iterationCount|justify|label|leftColor|leftStyle|leftWidth|length|level|line|lineStacking|lineStackingRuby|lineStackingShift|lineStackingStrategy|lines|list|mark|markAfter|markBefore|marks|marquee|marqueeDirection|marqueePlayCount|marqueeSpeed|marqueeStyle|max|min|model|moveTo|name|nav|navDown|navIndex|navLeft|navRight|navUp|new|numeral|offset|ordinalGroup|orient|origin|overflowStyle|overhang|pack|page|pagePolicy|pause|pauseAfter|pauseBefore|phonemes|pitch|pitchRange|playCount|playDuring|playState|point|presentation|presentationLevel|profile|property|punctuation|punctuationTrim|radius|rate|renderingIntent|repeat|replace|reset|resolution|resource|respondTo|rest|restAfter|restBefore|richness|rightColor|rightStyle|rightWidth|role|rotation|rotationPoint|rows|ruby|rubyOverhang|rubySpan|rule|ruleColor|ruleStyle|ruleWidth|shadow|size|sizeAdjust|sizing|space|spaceCollapse|spacing|span|speak|speakHeader|speakNumeral|speakPunctuation|speech|speechRate|speed|stacking|stackingRuby|stackingShift|stackingStrategy|stress|stretch|stringSet|style|styleImage|stylePosition|styleType|target|targetName|targetNew|targetPosition|text|textHeight|textJustify|textOutline|textReplace|textWrap|timingFunction|topColor|topLeftRadius|topRightRadius|topStyle|topWidth|trim|unicode|up|userSelect|variant|voice|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange|voiceRate|voiceStress|voiceVolume|volume|weight|white|whiteSpaceCollapse|word|wrap)\b
        name: support.type.property-name.css.protea
      - match: (?x)\b(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv|mso|prince)(?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+ \b
        name: support.type.vendored.property-name.css.protea

  css-value-names:
    comment: TODO
    patterns:
      - match: (?x)\b(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)\b
        name: support.constant.color.w3c-standard-color-name.css.protea
      - match: (?x)\b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen)\b
        name: support.constant.color.w3c-extended-color-name.css.protea
      - match: (?x)\b(currentColor)\b
        name: support.constant.color.current.css.protea
      - match: (?x)\b(ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText)\b
        name: support.constant.color.system.css.protea
      - match: (?x)\b(above|absolute|active|add|additive|afterEdge|alias|all|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternateReverse|always|antialiased|auto|autoPos|available|avoid|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|beforeEdge|below|bevel|bidiOverride|blink|block|blockAxis|blockStart|blockEnd|bold|bolder|border|borderBox|both|bottom|bottomOutside|breakAll|breakWord|bullets|butt|capitalize|caption|cell|center|central|char|circle|clip|clone|closeQuote|closestCorner|closestSide|colResize|collapse|color|colorBurn|colorDodge|column|columnReverse|commonLigatures|compact|condensed|contain|content|contentBox|contents|contextMenu|contextual|copy|cover|crispEdges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonalFractions|difference|digits|disabled|disc|discretionaryLigatures|distribute|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|doubleCircle|downleft|downright|eResize|eachLine|ease|easeIn|easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|evenodd|ewResize|exact|exclude|exclusion|expanded|extends|extraCondensed|extraExpanded|fallback|farthestCorner|farthestSide|fill|fillAvailable|fillBox|filled|fitContent|fixed|flat|flex|flexEnd|flexStart|flip|flowRoot|forwards|freeze|fromImage|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hardLight|help|hidden|hide|historicalForms|historicalLigatures|horizontal|horizontalTb|hue|icon|ideographAlpha|ideographNumeric|ideographParenthesis|ideographSpace|ideographic|inactive|infinite|inherit|initial|inline|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart|inlineTable|inset|inside|interCharacter|interIdeograph|interWord|intersect|invert|isolate|isolateOverride|italic|jis04|jis78|jis83|jis90|justify|justifyAll|kannada|keepAll|landscape|large|larger|left|lighten|lighter|line|lineEdge|lineThrough|linear|linearRGB|liningNums|listItem|local|loose|lowercase|lr|lrTb|ltr|luminance|luminosity|mainSize|mandatory|manipulation|manual|marginBox|matchParent|matchSource|mathematical|maxContent|medium|menu|messageBox|middle|minContent|miter|mixed|move|multiply|nResize|narrower|neResize|nearestNeighbor|neswResize|newspaper|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures|noDrop|noHistoricalLigatures|noOpenQuote|noRepeat|none|nonzero|normal|notAllowed|nowrap|nsResize|numbers|numeric|nwResize|nwseResize|oblique|oldstyleNums|open|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding|paddingBox|page|painted|panDown|panLeft|panRight|panUp|panX|panY|paused|petiteCaps|pixelated|plaintext|pointer|portrait|pre|preLine|preWrap|preserve3d|progress|progressive|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]|resetSize|reverse|revert|ridge|right|rl|rlTb|round|row|rowResize|rowReverse|rowSeverse|rtl|ruby|rubyBase|rubyBaseContainer|rubyText|rubyTextContainer|runIn|running|sResize|saturation|scaleDown|screen|scroll|scrollPosition|seResize|semiCondensed|semiExpanded|separate|sesame|show|sideways|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashedZero|slice|small|smallCaps|smallCaption|smaller|smooth|softLight|solid|space|spaceAround|spaceBetween|spaceEvenly|spellOut|square|sRGB|stackedFractions|start|static|statusBar|swap|stepEnd|stepStart|sticky|stretch|strict|stroke|strokeBox|style|sub|subgrid|subpixelAntialiased|subtract|super|swResize|symbolic|table|tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabularNums|tb|tbRl|text|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titlingCaps|top|topOutside|touch|traditional|transparent|triangle|ultraCondensed|ultraExpanded|under|underline|unicase|unset|upleft|uppercase|upright|useGlyphOrientation|useScript|verso|vertical|verticalIdeographic|verticalLr|verticalRl|verticalText|viewBox|visible|visibleFill|visiblePainted|visibleStroke|wResize|wait|wavy|weight|whitespace|wider|words|wrap|wrapReverse|x|xLarge|xSmall|xxLarge|xxSmall|y|zero|zoomIn|zoomOut)\b
        name: support.constant.property-value.css.protea
      - match: (?x)\b(arabicIndic|armenian|bengali|cambodian|circle|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic|decimal|decimalLeadingZero|devanagari|disc|disclosureClosed|disclosureOpen|ethiopicHalehameAm|ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangulConsonant|hebrew|hiragana|hiraganaIroha|japaneseFormal|japaneseInformal|kannada|katakana|katakanaIroha|khmer|koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lowerAlpha|lowerArmenian|lowerGreek|lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simpChineseFormal|simpChineseInformal|square|tamil|telugu|thai|tibetan|tradChineseFormal|tradChineseInformal|upperAlpha|upperArmenian|upperLatin|upperRoman|urdu)\b
        name: support.constant.property-value.list-style-type.css.protea
      - match: (?x)\b(arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|systemUi|system|tahoma|times|trebuchet|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings|sansSerif|serif|monospace)\b
        name: support.constant.font-name.css.protea

  html-tag-names:
    patterns:
      - match: (?x)\b(all|print|screen|speech|aural|braille|embossed|handheld|projection|tty|tv)\b
        name: support.constant.media.css.protea
      - match: (?x)\b(a|abbr|acronym|address|altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|annotation|annotationXml|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound|big|blink|blockquote|body|br|button|canvas|caption|center|circle|cite|clipPath|code|col|colgroup|colorProfile|command|content|cursor|data|datalist|dd|defs|del|desc|details|dfn|dialog|dir|discard|div|dl|dt|element|ellipse|em|embed|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|fieldset|figcaption|figure|filter|font|fontFace|fontFaceFormat|fontFaceName|fontFaceSrc|fontFaceUri|footer|foreignObject|form|frame|frameset|g|glyph|glyphRef|hatch|hatchpath|hd|head|header|hgroup|hkern|hr|html|h[1-6]|i|iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|line|linearGradient|link|listing|maction|main|maligngroup|malignmark|map|mark|marker|marquee|mask|math|menclose|menu|menuitem|merror|mesh|meshgradient|meshpatch|meshrow|meta|metadata|meter|mfenced|mfrac|mglyph|mi|missingGlyph|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mpath|mphantom|mroot|mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup|msup|mtable|mtd|mtext|mtr|multicol|munder|munderover|nav|nextid|nobr|noembed|noframes|noscript|object|ol|optgroup|option|output|p|param|path|pattern|picture|plaintext|polygon|polyline|pre|progress|q|radialGradient|rb|rect|rp|rt|rtc|ruby|s|samp|script|section|select|semantics|set|shadow|slot|small|solidcolor|source|spacer|span|stop|strike|strong|style|sub|summary|sup|svg|switch|symbol|table|tbody|td|template|text|textarea|textPath|tfoot|th|thead|time|title|tr|track|tref|tspan|tt|u|ul|use|var|video|view|vkern|wbr|xmp)\b
        name: entity.name.tag.css.protea

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Boolean|Bool|Char|Rune|String|Symbol
            |(Big)?(
              Number|Int(eger)?|Float|Decimal|Natural
              |Rational|Imaginary|Complex
            )|
            # lower flat case
            boolean|bool|char|rune|string|symbol
            |(big)?(
              number|int(eger)?|float|decimal|natural
              |rational|imaginary|complex
            )
          )\b
        name: support.type.builtin.primitive.protea
      - comment: Data query classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Array|Tuple|Set|Map|Object|Sequence|Record|Dictionary
            |Process|Range|Stack|Heap|Queue|Tree|Trie|Graph
            |Future|Stream|RegExp|Function|Buffer|FrozenSe[tq]
            # lower flat case
            |array|tuple|set|map|object|sequence|record|dictionary
            |process|range|stack|heap|queue|tree|trie|graph
            |future|stream|regexp|function|buffer|frozense[tq]
          )\b
        name: support.type.builtin.protea
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            True|False|Null|Void|NaN|Infinity|Empty|Unit|Object
            |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const|Undefined
            # lower flat case
            |true|false|null|void|nan|infinity|empty|unit|obj
            |any|mixed|just|some|none|never|(im)?pure|const|undefined
          )\b
        name: support.type.primitive.protea
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.protea
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.protea
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.protea
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)able\b
        name: support.class.trait.protea

  support-functions:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: predicate functions
        match: \s*\bis(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.protea
      - comment: magic functions
        match: \s*\b\p{Pc}+([\p{Pc}\p{L}]\w*)+\p{Pc}+\b\s*
        name: support.function.magic.protea

  # Generated

  strings-prefixed:
    patterns:
      - comment: single-quoted verbatim, interpolated, format, and template string
        begin: (?<!'+)((?i:fprs|fpsr|frps|frsp|fspr|fsrp|pfrs|pfsr|prfs|prsf|psfr|psrf|rfps|rfsp|rpfs|rpsf|rsfp|rspf|sfpr|sfrp|spfr|sprf|srfp|srpf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '''''|\$\$|%%|\#\#'
            name: constant.character.escape.protea
          - include: "#embedded-expression"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: double-quoted verbatim, interpolated, format, and template string
        begin: (?<!"+)((?i:fprs|fpsr|frps|frsp|fspr|fsrp|pfrs|pfsr|prfs|prsf|psfr|psrf|rfps|rfsp|rpfs|rpsf|rsfp|rspf|sfpr|sfrp|spfr|sprf|srfp|srpf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '""|\$\$|%%|\#\#'
            name: constant.character.escape.protea
          - include: "#embedded-expression"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: single-quoted verbatim, interpolated, and format string
        begin: (?<!'+)((?i:frs|fsr|rfs|rsf|sfr|srf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.protea
          - include: "#embedded-expression"
          - include: "#embedded-format"
      - comment: double-quoted verbatim, interpolated, and format string
        begin: (?<!"+)((?i:frs|fsr|rfs|rsf|sfr|srf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '""|\$\$|%%'
            name: constant.character.escape.protea
          - include: "#embedded-expression"
          - include: "#embedded-format"
      - comment: single-quoted verbatim, interpolated, and template string
        begin: (?<!'+)((?i:prs|psr|rps|rsp|spr|srp))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '''''|\$\$|\#\#'
            name: constant.character.escape.protea
          - include: "#embedded-expression"
          - include: "#embedded-placeholder"
      - comment: double-quoted verbatim, interpolated, and template string
        begin: (?<!"+)((?i:prs|psr|rps|rsp|spr|srp))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '""|\$\$|\#\#'
            name: constant.character.escape.protea
          - include: "#embedded-expression"
          - include: "#embedded-placeholder"
      - comment: single-quoted verbatim, format, and template string
        begin: (?<!'+)((?i:fpr|frp|pfr|prf|rfp|rpf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '''''|%%|\#\#'
            name: constant.character.escape.protea
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: double-quoted verbatim, format, and template string
        begin: (?<!"+)((?i:fpr|frp|pfr|prf|rfp|rpf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '""|%%|\#\#'
            name: constant.character.escape.protea
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: single-quoted interpolated, format, and template string
        begin: (?<!'+)((?i:fps|fsp|pfs|psf|sfp|spf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: double-quoted interpolated, format, and template string
        begin: (?<!"+)((?i:fps|fsp|pfs|psf|sfp|spf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: single-quoted verbatim and interpolated string
        begin: (?<!'+)((?i:rs|sr))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.protea
          - include: "#embedded-expression"
      - comment: double-quoted verbatim and interpolated string
        begin: (?<!"+)((?i:rs|sr))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '""|\$\$'
            name: constant.character.escape.protea
          - include: "#embedded-expression"
      - comment: single-quoted interpolated and format string
        begin: (?<!'+)((?i:fs|sf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-format"
      - comment: double-quoted interpolated and format string
        begin: (?<!"+)((?i:fs|sf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-format"
      - comment: single-quoted verbatim and template string
        begin: (?<!'+)((?i:pr|rp))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '''''|\#\#'
            name: constant.character.escape.protea
          - include: "#embedded-placeholder"
      - comment: double-quoted verbatim and template string
        begin: (?<!"+)((?i:pr|rp))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '""|\#\#'
            name: constant.character.escape.protea
          - include: "#embedded-placeholder"
      - comment: single-quoted interpolated and template string
        begin: (?<!'+)((?i:ps|sp))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-placeholder"
      - comment: double-quoted interpolated and template string
        begin: (?<!"+)((?i:ps|sp))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-placeholder"
      - comment: single-quoted format and template string
        begin: (?<!'+)((?i:fp|pf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: double-quoted format and template string
        begin: (?<!"+)((?i:fp|pf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: single-quoted verbatim string
        begin: (?<!'+)((?i:r))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: "''"
            name: constant.character.escape.protea
      - comment: double-quoted verbatim string
        begin: (?<!"+)((?i:r))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - match: '""'
            name: constant.character.escape.protea
      - comment: single-quoted interpolated string
        begin: (?<!'+)((?i:s))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
      - comment: double-quoted interpolated string
        begin: (?<!"+)((?i:s))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
      - comment: single-quoted template string
        begin: (?<!'+)((?i:p))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-placeholder"
      - comment: double-quoted template string
        begin: (?<!"+)((?i:p))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.protea}
          2: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-placeholder"
